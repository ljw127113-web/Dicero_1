<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç« èŠ‚è¡¨æ ¼ç”Ÿæˆå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .upload-section {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 25px 30px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f0ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8e8ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 2.5em;
            color: #667eea;
            margin-bottom: 10px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 10px;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-info {
            margin-top: 20px;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 8px;
            display: none;
        }

        .file-info.show {
            display: block;
        }

        .file-info strong {
            color: #667eea;
        }

        .controls {
            padding: 20px 30px;
            background: white;
            border-bottom: 2px solid #e9ecef;
            display: none;
        }

        .controls.show {
            display: block;
        }

        .sheet-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }

        .sheet-tab {
            padding: 10px 20px;
            background: #f0f0f0;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .sheet-tab:hover {
            background: #e0e0e0;
        }

        .sheet-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .display-section {
            padding: 30px;
            background: white;
            display: none;
        }

        .display-section.show {
            display: block;
        }

        .table-wrapper {
            overflow: auto;
            max-height: 600px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
        }

        .excel-table {
            border-collapse: collapse;
            width: 100%;
            min-width: 100%;
            font-size: 0.9em;
        }

        .excel-table th,
        .excel-table td {
            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: left;
            white-space: nowrap;
        }

        .excel-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 600;
        }

        .excel-table th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            background: linear-gradient(135deg, #5568d3 0%, #653a92 100%);
        }

        .excel-table td:first-child {
            position: sticky;
            left: 0;
            background: #f8f9fa;
            font-weight: 600;
            z-index: 9;
            text-align: center;
        }

        .excel-table tbody tr:nth-child(even) {
            background: #f8f9fa;
        }

        .excel-table tbody tr:hover {
            background: #e7f3ff;
        }

        .row-header {
            background: #6c757d !important;
            color: white !important;
            min-width: 50px;
            text-align: center !important;
        }

        .empty-cell {
            background: #e9ecef;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .config-section {
            border: 2px solid #e9ecef;
        }

        .config-section label {
            color: #495057;
        }

        .config-section input,
        .config-section select {
            font-size: 1em;
        }

        #chapterIdsList {
            border: 1px solid #dee2e6;
        }

        #chapterIdsDisplay {
            margin-left: 10px;
            color: #667eea;
            font-weight: 600;
        }

        .step-section {
            margin: 20px 0;
        }

        .step-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .step-tab {
            padding: 12px 25px;
            background: #f0f0f0;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 1em;
        }

        .step-tab:hover {
            background: #e0e0e0;
        }

        .step-tab.active {
            background: white;
            border-bottom-color: #667eea;
            color: #667eea;
        }

        .step-content {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .step-panel h3 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .step-panel h4 {
            color: #495057;
            margin-bottom: 15px;
        }

        .config-table-wrapper {
            margin-top: 20px;
            max-height: 500px;
            overflow: auto;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.9em;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š ç« èŠ‚è¡¨æ ¼ç”Ÿæˆå™¨</h1>
            <p>ä¸Šä¼ Excelæ–‡ä»¶ï¼ŒæŸ¥çœ‹å’Œç”Ÿæˆæ–°çš„è¡¨æ ¼</p>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">ç‰ˆæœ¬å·: <span id="versionNumber">1.0.21</span></p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <h2 style="font-size: 1.3em; margin: 8px 0;">æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ </h2>
                <p style="margin-top: 5px; color: #666; font-size: 0.9em;">æ”¯æŒ .xlsx, .xlsm, .xls æ ¼å¼</p>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xlsm,.xls">
                <button class="upload-btn" type="button" id="uploadBtn">é€‰æ‹©æ–‡ä»¶</button>
            </div>
            <div class="file-info" id="fileInfo"></div>
        </div>

        <div class="controls" id="controls" style="display: none;">
            <div class="sheet-tabs" id="sheetTabs"></div>
        </div>

        <div class="display-section" id="displaySection">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>æ­£åœ¨åŠ è½½æ–‡ä»¶...</p>
            </div>
            <div id="tableContainer" style="display: none;"></div>
        </div>

        <div class="controls" id="stepControls" style="display: none;">
            <div class="step-section" id="stepSection">
                <div class="step-tabs">
                    <div class="step-tab active" data-step="1">æ­¥éª¤1: æºæ–‡ä»¶æ˜¾ç¤º</div>
                    <div class="step-tab" data-step="2">æ­¥éª¤2: æ•°æ®å¤„ç†</div>
                    <div class="step-tab" data-step="3">æ­¥éª¤3: å¯¼å‡ºæ–‡ä»¶</div>
                </div>
                <div class="step-content" id="stepContent">
                    <!-- æ­¥éª¤1å†…å®¹ï¼šæºæ–‡ä»¶æ˜¾ç¤º -->
                    <div class="step-panel" id="step1Panel">
                        <h3>æºæ–‡ä»¶æ˜¾ç¤º</h3>
                        <div style="padding: 20px; background: #f8f9fa; border-radius: 8px; margin-bottom: 20px;">
                            <p style="margin-bottom: 15px; color: #495057;">ä¸Šæ–¹æ˜¾ç¤ºäº†æºæ–‡ä»¶çš„æ‰€æœ‰sheeté¡µæ ‡ç­¾ï¼Œç‚¹å‡»æ ‡ç­¾å¯ä»¥åˆ‡æ¢æŸ¥çœ‹ä¸åŒçš„sheeté¡µã€‚</p>
                            <p style="margin-bottom: 15px; color: #495057;">è¡¨æ ¼ä¸­æ˜¾ç¤ºäº†è¡Œå·ï¼ˆç¬¬ä¸€åˆ—ï¼‰å’Œåˆ—å·ï¼ˆè¡¨å¤´ï¼‰ï¼Œæ–¹ä¾¿æŸ¥çœ‹æ•°æ®ä½ç½®ã€‚</p>
                            <div style="background: white; padding: 15px; border-radius: 5px; border-left: 4px solid #667eea;">
                                <strong style="color: #667eea;">æç¤ºï¼š</strong>
                                <ul style="margin-top: 10px; padding-left: 20px; color: #6c757d;">
                                    <li>ç‚¹å‡»ä¸Šæ–¹çš„sheetæ ‡ç­¾å¯ä»¥åˆ‡æ¢ä¸åŒçš„sheeté¡µ</li>
                                    <li>è¡¨æ ¼ç¬¬ä¸€åˆ—æ˜¾ç¤ºè¡Œå·ï¼ˆ1, 2, 3...ï¼‰</li>
                                    <li>è¡¨æ ¼è¡¨å¤´æ˜¾ç¤ºåˆ—å·ï¼ˆA, B, C...ï¼‰</li>
                                    <li>è¡¨æ ¼æ”¯æŒæ¨ªå‘å’Œçºµå‘æ»šåŠ¨</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <!-- æ­¥éª¤2å†…å®¹ï¼šæ•°æ®å¤„ç† -->
                    <div class="step-panel" id="step2Panel" style="display: none;">
                        <h3>æ•°æ®å¤„ç†</h3>
                        <div style="padding: 20px; background: #f8f9fa; border-radius: 8px; margin-bottom: 20px;">
                            <p style="margin-bottom: 15px;">å°†æ ¹æ®"å…³å¡è§„åˆ’æ€»"sheeté¡µçš„æ•°æ®ç”Ÿæˆ"æ€ªç‰©ç»„"sheeté¡µçš„"æ•Œäººç»„ID"åˆ—æ•°æ®</p>
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px; font-weight: 500;">ç”Ÿæˆé€‰é¡¹:</label>
                                <div style="margin-bottom: 10px;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="radio" name="processOption" value="all" checked style="margin-right: 8px;">
                                        <span>å…¨éƒ¨ç”Ÿæˆ</span>
                                    </label>
                                    <label style="display: flex; align-items: center; cursor: pointer; margin-top: 8px;">
                                        <input type="radio" name="processOption" value="single" style="margin-right: 8px;">
                                        <span>åˆ†ç« èŠ‚ç”Ÿæˆ</span>
                                    </label>
                                </div>
                                <div id="singleChapterProcessInput" style="display: none; margin-top: 10px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">ç« èŠ‚ID:</label>
                                    <input type="number" id="singleChapterProcessId" placeholder="è¯·è¾“å…¥ç« èŠ‚ID" min="1" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                </div>
                            </div>
                            <button class="btn btn-primary" onclick="processData()">å¤„ç†æ•°æ®</button>
                            <div id="processResult" style="margin-top: 15px; padding: 10px; background: white; border-radius: 5px; display: none;"></div>
                        </div>
                        <div id="processedDataDisplay" style="display: none;">
                            <h4 style="margin-bottom: 10px;">å¤„ç†åçš„æ•°æ®é¢„è§ˆ</h4>
                            <div id="processedSheetTabs" class="sheet-tabs"></div>
                            <div id="processedTableContainer"></div>
                        </div>
                    </div>
                    <!-- æ­¥éª¤3å†…å®¹ï¼šå¯¼å‡ºæ–‡ä»¶ -->
                    <div class="step-panel" id="step3Panel" style="display: none;">
                        <h3>å¯¼å‡ºæ–‡ä»¶</h3>
                        <div style="padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <p style="margin-bottom: 15px;">æŒ‰ç« èŠ‚å¯¼å‡ºå¤„ç†åçš„æ•°æ®ä¸ºæ–°çš„xlsxæ–‡ä»¶</p>
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px; font-weight: 500;">å¯¼å‡ºé€‰é¡¹:</label>
                                <div style="margin-bottom: 10px;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="radio" name="exportOption" value="all" checked style="margin-right: 8px;">
                                        <span>å¯¼å‡ºå…¨éƒ¨ç« èŠ‚</span>
                                    </label>
                                    <label style="display: flex; align-items: center; cursor: pointer; margin-top: 8px;">
                                        <input type="radio" name="exportOption" value="single" style="margin-right: 8px;">
                                        <span>å¯¼å‡ºå•ä¸ªç« èŠ‚</span>
                                    </label>
                                </div>
                                <div id="singleChapterInput" style="display: none; margin-top: 10px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">ç« èŠ‚ID:</label>
                                    <input type="number" id="singleChapterId" placeholder="è¯·è¾“å…¥ç« èŠ‚ID" min="1" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                </div>
                            </div>
                            <button class="btn btn-primary" onclick="exportFiles()" style="margin-right: 10px;">å¯¼å‡ºç« èŠ‚æ–‡ä»¶</button>
                            <button class="btn btn-secondary" onclick="exportMonsterGroup()">å¯¼å‡ºæ€ªç‰©ç»„ï¼ˆå¸¦ç‰ˆæœ¬å·ï¼‰</button>
                            <div id="exportResult" style="margin-top: 15px; padding: 10px; background: white; border-radius: 5px; display: none;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="clearFile()">æ¸…é™¤æ–‡ä»¶</button>
            </div>
        </div>
    </div>

    <script>
        // ç‰ˆæœ¬å·é…ç½® - æ¯æ¬¡ä»£ç ä¿®æ”¹æ—¶ï¼Œå°†æœ€åä¸€ä¸ªç‚¹åé¢çš„æ•°å­—+1ï¼ˆæœ€å¤§9999ï¼Œä¸­é—´ä½ä¿æŒä¸º0ç”±ç”¨æˆ·æ‰‹åŠ¨æå‡ï¼‰
        const VERSION = '1.0.21';
        
        // æ˜¾ç¤ºç‰ˆæœ¬å·
        document.addEventListener('DOMContentLoaded', () => {
            const versionElement = document.getElementById('versionNumber');
            if (versionElement) {
                versionElement.textContent = VERSION;
            }
            
            // æ·»åŠ å¯¼å‡ºé€‰é¡¹åˆ‡æ¢äº‹ä»¶
            const exportOptions = document.querySelectorAll('input[name="exportOption"]');
            const singleChapterInput = document.getElementById('singleChapterInput');
            if (exportOptions.length > 0 && singleChapterInput) {
                exportOptions.forEach(option => {
                    option.addEventListener('change', (e) => {
                        if (e.target.value === 'single') {
                            singleChapterInput.style.display = 'block';
                        } else {
                            singleChapterInput.style.display = 'none';
                        }
                    });
                });
            }
            
            // æ·»åŠ å¤„ç†æ•°æ®é€‰é¡¹åˆ‡æ¢äº‹ä»¶
            const processOptions = document.querySelectorAll('input[name="processOption"]');
            const singleChapterProcessInput = document.getElementById('singleChapterProcessInput');
            if (processOptions.length > 0 && singleChapterProcessInput) {
                processOptions.forEach(option => {
                    option.addEventListener('change', (e) => {
                        if (e.target.value === 'single') {
                            singleChapterProcessInput.style.display = 'block';
                        } else {
                            singleChapterProcessInput.style.display = 'none';
                        }
                    });
                });
            }
        });

        let workbook = null;
        let currentSheetName = null;
        let workbookData = null;
        let globalGeneratedData = null; // å­˜å‚¨ç”Ÿæˆçš„æ€ªç‰©ç»„æ•°æ®ï¼Œä¾›å¯¼å‡ºä½¿ç”¨
        let globalPlanData = null; // å­˜å‚¨"å…³å¡è§„åˆ’æ€»"çš„åŸå§‹æ•°æ®ï¼Œä¾›å¯¼å‡ºä½¿ç”¨

        // æ–‡ä»¶ä¸Šä¼ åŒºåŸŸäº‹ä»¶
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInfo = document.getElementById('fileInfo');
        const controls = document.getElementById('controls');
        const stepControls = document.getElementById('stepControls');
        const displaySection = document.getElementById('displaySection');
        const sheetTabs = document.getElementById('sheetTabs');
        const tableContainer = document.getElementById('tableContainer');
        const loading = document.getElementById('loading');

        // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸï¼ˆä½†æ’é™¤æŒ‰é’®ï¼‰
        uploadArea.addEventListener('click', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®æˆ–å…¶å­å…ƒç´ ï¼Œä¸å¤„ç†
            if (e.target === uploadBtn || uploadBtn.contains(e.target)) {
                return;
            }
            fileInput.click();
        });

        // ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æŒ‰é’®
        uploadBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°uploadArea
            fileInput.click();
        });

        // æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // æ‹–æ‹½ä¸Šä¼ 
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && (file.name.endsWith('.xlsx') || file.name.endsWith('.xlsm') || file.name.endsWith('.xls'))) {
                handleFile(file);
            } else {
                alert('è¯·ä¸Šä¼ æœ‰æ•ˆçš„Excelæ–‡ä»¶ï¼ˆ.xlsx, .xlsm, .xlsï¼‰');
            }
        });

        // å¤„ç†æ–‡ä»¶
        function handleFile(file) {
            loading.style.display = 'block';
            tableContainer.style.display = 'none';
            displaySection.classList.add('show');

            fileInfo.innerHTML = `<strong>å·²é€‰æ‹©æ–‡ä»¶ï¼š</strong> ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
            fileInfo.classList.add('show');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    workbook = XLSX.read(data, { type: 'array', cellStyles: true });
                    workbookData = workbook;
                    
                    displayWorkbook(workbook);
                } catch (error) {
                    console.error('è¯»å–æ–‡ä»¶é”™è¯¯:', error);
                    alert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®');
                    loading.style.display = 'none';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // æ˜¾ç¤ºå·¥ä½œç°¿ - ç¬¬ä¸€éƒ¨åˆ†ï¼šæºæ–‡ä»¶æ˜¾ç¤º
        function displayWorkbook(wb) {
            const sheetNames = wb.SheetNames;
            
            if (!sheetTabs) {
                console.error('sheetTabså…ƒç´ æœªæ‰¾åˆ°');
                alert('é”™è¯¯ï¼šæ— æ³•æ‰¾åˆ°sheetæ ‡ç­¾å®¹å™¨');
                return;
            }
            
            if (sheetNames.length === 0) {
                console.warn('æ²¡æœ‰æ‰¾åˆ°sheeté¡µ');
                alert('é”™è¯¯ï¼šæ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°sheeté¡µ');
                return;
            }
            
            // åˆ›å»ºsheetæ ‡ç­¾
            sheetTabs.innerHTML = '';
            sheetNames.forEach((name, index) => {
                const tab = document.createElement('div');
                tab.className = 'sheet-tab' + (index === 0 ? ' active' : '');
                tab.textContent = name;
                tab.onclick = () => switchSheet(name);
                sheetTabs.appendChild(tab);
            });

            // æ˜¾ç¤ºcontrolsåŒºåŸŸï¼ˆsheetTabsåŒºåŸŸï¼Œè´´è¿‘è¡¨æ ¼ï¼‰
            controls.classList.add('show');
            controls.style.display = 'block'; // ç¡®ä¿æ˜¾ç¤º
            
            // æ˜¾ç¤ºæ­¥éª¤æ§åˆ¶åŒºåŸŸï¼ˆæ”¾åœ¨æœ€ä¸‹é¢ï¼‰
            if (stepControls) {
                stepControls.classList.add('show');
                stepControls.style.display = 'block';
            }
            
            // ç¡®ä¿sheetTabså¯è§
            sheetTabs.style.display = 'flex';
            sheetTabs.style.visibility = 'visible';
            
            console.log('å·²åˆ›å»º', sheetNames.length, 'ä¸ªsheetæ ‡ç­¾');
            console.log('sheetTabså…ƒç´ :', sheetTabs);
            console.log('controlsæ˜¯å¦æ˜¾ç¤º:', controls.classList.contains('show'));
            
            // åˆå§‹åŒ–æ­¥éª¤åˆ‡æ¢
            initStepTabs();
            
            // æ˜¾ç¤ºç¬¬ä¸€ä¸ªsheet
            if (sheetNames.length > 0) {
                currentSheetName = sheetNames[0];
                displaySheet(wb.Sheets[currentSheetName], currentSheetName);
            }

            loading.style.display = 'none';
        }

        // åˆå§‹åŒ–æ­¥éª¤æ ‡ç­¾
        function initStepTabs() {
            const stepTabs = document.querySelectorAll('.step-tab');
            stepTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const step = tab.getAttribute('data-step');
                    switchStep(step);
                });
            });
            // é»˜è®¤æ˜¾ç¤ºæ­¥éª¤1
            switchStep('1');
        }

        // åˆ‡æ¢æ­¥éª¤
        function switchStep(step) {
            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            document.querySelectorAll('.step-tab').forEach(tab => {
                if (tab.getAttribute('data-step') === step) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // æ˜¾ç¤ºå¯¹åº”çš„é¢æ¿
            document.getElementById('step1Panel').style.display = step === '1' ? 'block' : 'none';
            document.getElementById('step2Panel').style.display = step === '2' ? 'block' : 'none';
            document.getElementById('step3Panel').style.display = step === '3' ? 'block' : 'none';
            
            // ç¡®ä¿æºæ–‡ä»¶æ˜¾ç¤ºåŒºåŸŸåœ¨æ­¥éª¤1æ—¶æ˜¾ç¤º
            if (step === '1' && workbook && displaySection) {
                displaySection.classList.add('show');
            }
        }

        // åˆ‡æ¢sheet
        function switchSheet(sheetName) {
            currentSheetName = sheetName;
            
            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            document.querySelectorAll('.sheet-tab').forEach((tab, index) => {
                if (workbook.SheetNames[index] === sheetName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            displaySheet(workbook.Sheets[sheetName], sheetName);
        }

        // Excelåˆ—å·è½¬æ¢ï¼ˆ1->A, 2->B, ..., 27->AA, ...ï¼‰
        function getExcelColumnName(colIndex) {
            let result = '';
            while (colIndex >= 0) {
                result = String.fromCharCode(65 + (colIndex % 26)) + result;
                colIndex = Math.floor(colIndex / 26) - 1;
            }
            return result;
        }

        // æ˜¾ç¤ºsheetæ•°æ®
        function displaySheet(sheet, sheetName) {
            loading.style.display = 'block';
            tableContainer.style.display = 'none';

            setTimeout(() => {
                const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
                
                // åˆ›å»ºè¡¨æ ¼
                let html = '<div class="table-wrapper"><table class="excel-table"><thead><tr>';
                
                // è¡¨å¤´ï¼šç©ºå•å…ƒæ ¼ + åˆ—å·ï¼ˆA, B, C...ï¼‰
                html += '<th class="row-header">è¡Œ/åˆ—</th>';
                for (let C = range.s.c; C <= range.e.c; C++) {
                    const colName = getExcelColumnName(C);
                    html += `<th>${colName}</th>`;
                }
                html += '</tr></thead><tbody>';

                // æ•°æ®è¡Œ
                for (let R = range.s.r; R <= range.e.r; R++) {
                    html += '<tr>';
                    // è¡Œå·
                    html += `<td class="row-header">${R + 1}</td>`;
                    
                    // æ•°æ®å•å…ƒæ ¼
                    for (let C = range.s.c; C <= range.e.c; C++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                        const cell = sheet[cellAddress];
                        const cellValue = cell ? (cell.w || cell.v || '') : '';
                        const displayValue = cellValue === '' ? '&nbsp;' : escapeHtml(String(cellValue));
                        html += `<td>${displayValue}</td>`;
                    }
                    html += '</tr>';
                }

                html += '</tbody></table></div>';
                
                tableContainer.innerHTML = html;
                loading.style.display = 'none';
                tableContainer.style.display = 'block';
            }, 100);
        }

        // HTMLè½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // è‡ªåŠ¨æ£€æµ‹ç« èŠ‚IDåˆ—
        function detectChapterIdColumn() {
            if (!workbookData) return;
            
            // å°è¯•æ‰¾åˆ°"ç« èŠ‚æ€»"ç›¸å…³çš„sheeté¡µ
            let targetSheet = null;
            let targetSheetName = null;
            
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('ç« èŠ‚æ€»') || sheetName.includes('æ€»è¡¨')) {
                    targetSheet = workbookData.Sheets[sheetName];
                    targetSheetName = sheetName;
                    break;
                }
            }
            
            if (!targetSheet && workbookData.SheetNames.length > 0) {
                targetSheet = workbookData.Sheets[workbookData.SheetNames[0]];
                targetSheetName = workbookData.SheetNames[0];
            }
            
            if (!targetSheet) return;
            
            // è¯»å–sheetæ•°æ®
            const data = XLSX.utils.sheet_to_json(targetSheet, { header: 1, defval: '' });
            
            // å°è¯•æŸ¥æ‰¾åŒ…å«"ç« èŠ‚"ã€"id"ã€"ç« èŠ‚ID"ç­‰å…³é”®è¯çš„åˆ—
            if (data.length > 0) {
                const firstRow = data[0];
                for (let i = 0; i < firstRow.length; i++) {
                    const header = String(firstRow[i]).toLowerCase();
                    if (header.includes('ç« èŠ‚') && (header.includes('id') || header.includes('ç¼–å·'))) {
                        const colName = XLSX.utils.encode_col(i);
                        document.getElementById('chapterIdCol').value = colName;
                        extractChapterIds(targetSheet, colName);
                        return;
                    }
                }
                
                // å¦‚æœç¬¬ä¸€è¡Œæ²¡æ‰¾åˆ°ï¼Œå°è¯•æŸ¥æ‰¾åŒ…å«æ•°å­—çš„åˆ—
                for (let col = 0; col < data[0].length; col++) {
                    let hasNumericIds = false;
                    for (let row = 1; row < Math.min(10, data.length); row++) {
                        const val = data[row][col];
                        if (val !== '' && val !== null && val !== undefined) {
                            const numVal = Number(val);
                            if (!isNaN(numVal) && numVal > 0 && numVal % 1 === 0) {
                                hasNumericIds = true;
                                break;
                            }
                        }
                    }
                    if (hasNumericIds) {
                        const colName = XLSX.utils.encode_col(col);
                        document.getElementById('chapterIdCol').value = colName;
                        extractChapterIds(targetSheet, colName);
                        return;
                    }
                }
            }
        }

        // æå–ç« èŠ‚ID
        function extractChapterIds(sheet, colName) {
            if (!colName) {
                colName = document.getElementById('chapterIdCol').value;
            }
            
            if (!colName || !sheet) return;
            
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
            const colIndex = XLSX.utils.decode_col(colName);
            
            const chapterIds = new Set();
            for (let row = 1; row < data.length; row++) {
                const val = data[row][colIndex];
                if (val !== '' && val !== null && val !== undefined) {
                    const numVal = Number(val);
                    if (!isNaN(numVal) && numVal > 0 && numVal % 1 === 0) {
                        chapterIds.add(numVal);
                    }
                }
            }
            
            const sortedIds = Array.from(chapterIds).sort((a, b) => a - b);
            document.getElementById('chapterIdsDisplay').textContent = sortedIds.join(', ');
            document.getElementById('chapterIdsList').style.display = sortedIds.length > 0 ? 'block' : 'none';
            
            return sortedIds;
        }

        // åˆ›å»ºstage_id sheeté¡µ
        function createStageSheet(chapterId, stageData) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            // è®¾ç½®å‰5è¡Œçš„å›ºå®šå€¼
            // æ ¹æ®éœ€æ±‚ï¼š
            // Aåˆ—å‰5è¡Œ: "##var","##var","##type","##group","##"
            // Båˆ—å‰5è¡Œ: "id","","int","c,s","å±‚ID"
            // Cåˆ—å‰5è¡Œ: "chapter","","int","c,s","ç« èŠ‚ID"
            // Dåˆ—å‰5è¡Œ: "stage","","int","c,s","å±‚ID"
            // Eåˆ—å‰5è¡Œ: "stageType","","int","c,s","å±‚ç±»å‹"
            // Fåˆ—å‰5è¡Œ: "bossAnim","","(array#sep=*),float","c,s","BOSSè™šå½±"
            // Gåˆ—å‰5è¡Œ: "stageExp","","int","c,s","è¿‡å…³ç»éªŒå€¼"
            
            const headerData = [
                ['##var', '##var', '##var', '##var', '##var', '##var', '##var'], // ç¬¬1è¡Œ
                ['##var', 'id', 'chapter', 'stage', 'stageType', 'bossAnim', 'stageExp'], // ç¬¬2è¡Œ
                ['##type', 'int', 'int', 'int', 'int', '(array#sep=*),float', 'int'], // ç¬¬3è¡Œ
                ['##group', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s'], // ç¬¬4è¡Œ
                ['##', 'å±‚ID', 'ç« èŠ‚ID', 'å±‚ID', 'å±‚ç±»å‹', 'BOSSè™šå½±', 'è¿‡å…³ç»éªŒå€¼'] // ç¬¬5è¡Œ
            ];
            
            // å†™å…¥è¡¨å¤´ï¼ˆå‰5è¡Œï¼‰
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 7; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = headerData[row][col] || '';
                    sheet[cellAddress] = { v: value, t: 's' };
                }
            }
            
            // ä»stageDataå¡«å……æ•°æ®ï¼ˆä»ç¬¬6è¡Œå¼€å§‹ï¼Œç´¢å¼•5ï¼‰
            // æ ¹æ®éœ€æ±‚ï¼šBåˆ—è¯»å–"å…³å¡è§„åˆ’æ€»"sheeté¡µä¸­Aåˆ—æ‰€æœ‰ä¸ºè¯¥idçš„Båˆ—å€¼
            // è¿™é‡Œå°†Båˆ—å€¼å¡«å…¥Båˆ—ï¼ˆä»ç¬¬6è¡Œå¼€å§‹ï¼‰
            if (stageData && stageData.length > 0) {
                stageData.forEach((item, index) => {
                    const row = 5 + index; // ä»ç¬¬6è¡Œå¼€å§‹ï¼ˆç´¢å¼•5ï¼‰
                    
                    // Båˆ—ï¼ˆç´¢å¼•1ï¼‰å¡«å…¥ä»å…³å¡è§„åˆ’æ€»è¯»å–çš„Båˆ—å€¼
                    const bValue = item.bValue || item;
                    const cellAddressB = XLSX.utils.encode_cell({ r: row, c: 1 }); // Båˆ—
                    sheet[cellAddressB] = { 
                        v: typeof bValue === 'object' ? bValue.bValue : bValue, 
                        t: typeof bValue === 'number' ? 'n' : 's' 
                    };
                    
                    // Cåˆ—ï¼ˆç´¢å¼•2ï¼‰å¡«å…¥ç« èŠ‚ID
                    const cellAddressC = XLSX.utils.encode_cell({ r: row, c: 2 }); // Cåˆ—
                    sheet[cellAddressC] = { v: chapterId, t: 'n' };
                });
            }
            
            // è®¾ç½®èŒƒå›´
            const maxRow = Math.max(4, 5 + (stageData ? stageData.length - 1 : 0));
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: maxRow, c: 6 } });
            
            return sheet;
        }

        // åˆ›å»ºstageEvent_id sheeté¡µ
        function createStageEventSheet(chapterId) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            const headerData = [
                ['##var', '##var', '##var', '##var'],
                ['##var', 'id', 'eventId', 'eventFirst'],
                ['##type', 'int', '(array#sep=|),(array#sep=*),int', 'int'],
                ['##group', 'c,s', 'c,s', 'c,s'],
                ['##', 'å±‚ID', 'äº‹ä»¶éšæœº', 'é¦–æ¬¡äº‹ä»¶']
            ];
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    sheet[cellAddress] = { v: headerData[row][col], t: 's' };
                }
            }
            
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: 4, c: 3 } });
            return sheet;
        }

        // åˆ›å»ºstageBattle_id sheeté¡µ
        function createStageBattleSheet(chapterId) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            const headerData = [
                ['##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var'],
                ['##var', 'id', 'hp', 'atk', 'firstHp', 'firstAtk', 'group', 'rogue', 'point', 'roll', 'diceHand', 'prop', 'enemyExp', 'stageExp'],
                ['##type', 'int', 'int', 'int', 'int', 'int', '(array#sep=*),int', '(array#sep=*),int', '(array#sep=|),(array#sep=*),int', '(array#sep=|),(array#sep=*),int', '(array#sep=*),int', '(array#sep=|),(array#sep=*),int', 'int', 'int'],
                ['##group', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s'],
                ['##', 'å±‚ID', 'æ ‡å‡†è¡€é‡', 'æ ‡å‡†æ”»å‡»åŠ›', 'ç¬¬ä¸€æ¬¡è¡€é‡', 'ç¬¬ä¸€æ¬¡æ”»å‡»åŠ›', 'éšæœºæ•Œäººç»„', 'ç»“æŸæ˜¯å¦æœ‰rogue', 'ç¬¬ä¸€æ¬¡åˆ°è¾¾å¿…å‡ºç‚¹æ•°', 'ç¬¬å‡ æ¬¡é‡ç½®å‡ºæŸä¸ªç‚¹æ•°', 'ç‰Œå‹æ¦‚ç‡', 'é“å…·æ‰è½', 'å•æ€ªæ‰è½ç»éªŒå€¼', 'è¿‡å…³ç»éªŒå€¼']
            ];
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 14; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    sheet[cellAddress] = { v: headerData[row][col], t: 's' };
                }
            }
            
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: 4, c: 13 } });
            return sheet;
        }

        // åˆ›å»ºgroup_id sheeté¡µ
        function createGroupSheet(chapterId) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            const headerData = [
                ['##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var'],
                ['##var', 'id', 'groupId', 'enemy', 'position', 'start', 'passiveSkill', 'hpTimes', 'atkTimes', 'skillOrder'],
                ['##type', 'int', 'int', 'temp.EEnemy', 'int', '(array#sep=*),int', '(array#sep=*),int', '(array#sep=*),float', '(array#sep=*),float', '(array#sep=*),temp.EEnemyBehavior'],
                ['##group', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s'],
                ['##', 'å”¯ä¸€ID', 'æ•Œäººç»„ID', 'æ•ŒäººID', 'ç«™ä½', 'æ€ªç‰©åˆå§‹çŠ¶æ€', 'å¸¸é©»è¢«åŠ¨æŠ€èƒ½', 'æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´', 'æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´', 'æŠ€èƒ½é¡ºåº']
            ];
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 10; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    sheet[cellAddress] = { v: headerData[row][col], t: 's' };
                }
            }
            
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: 4, c: 9 } });
            return sheet;
        }

        // ä»å…³å¡è§„åˆ’æ€»è¯»å–æ•°æ®
        function getStageDataFromPlanSheet(chapterId) {
            const stagePlanSheetName = document.getElementById('stagePlanSheet').value;
            let planSheet = null;
            
            // å¦‚æœæŒ‡å®šäº†sheeté¡µåï¼Œä½¿ç”¨æŒ‡å®šçš„ï¼›å¦åˆ™è‡ªåŠ¨æŸ¥æ‰¾
            if (stagePlanSheetName) {
                planSheet = workbookData.Sheets[stagePlanSheetName];
            } else {
                // è‡ªåŠ¨æŸ¥æ‰¾åŒ…å«"å…³å¡è§„åˆ’æ€»"çš„sheeté¡µ
                for (let name of workbookData.SheetNames) {
                    if (name.includes('å…³å¡è§„åˆ’æ€»') || name.includes('è§„åˆ’æ€»')) {
                        planSheet = workbookData.Sheets[name];
                        break;
                    }
                }
            }
            
            if (!planSheet) {
                console.warn('æœªæ‰¾åˆ°å…³å¡è§„åˆ’æ€»sheeté¡µ');
                return [];
            }
            
            const data = XLSX.utils.sheet_to_json(planSheet, { header: 1, defval: '' });
            
            // Aåˆ—ï¼ˆç´¢å¼•0ï¼‰æ˜¯ç« èŠ‚IDåˆ—
            // Båˆ—ï¼ˆç´¢å¼•1ï¼‰æ˜¯è¦è¯»å–çš„å€¼
            const chapterIdCol = 0; // Aåˆ—
            const valueCol = 1; // Båˆ—
            
            const stageData = [];
            
            // éå†æ‰€æœ‰è¡Œï¼Œæ‰¾åˆ°Aåˆ—ç­‰äºè¯¥ç« èŠ‚IDçš„è¡Œï¼Œè¯»å–Båˆ—çš„å€¼
            for (let row = 0; row < data.length; row++) {
                const rowChapterId = data[row][chapterIdCol];
                if (rowChapterId !== '' && rowChapterId !== null && rowChapterId !== undefined) {
                    const numId = Number(rowChapterId);
                    // æ£€æŸ¥æ˜¯å¦åŒ¹é…ç« èŠ‚ID
                    if (!isNaN(numId) && numId === chapterId) {
                        const bValue = data[row][valueCol];
                        if (bValue !== '' && bValue !== null && bValue !== undefined) {
                            // å°†Båˆ—çš„å€¼ä½œä¸ºæ•°æ®ï¼Œè¿™é‡Œéœ€è¦æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´æ•°æ®ç»“æ„
                            // æ ¹æ®éœ€æ±‚ï¼ŒBåˆ—å€¼åº”è¯¥å¡«å…¥stage sheetçš„æŸä¸ªä½ç½®
                            // ç›®å‰å…ˆä¿å­˜Båˆ—çš„å€¼ï¼Œåç»­å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´
                            stageData.push({
                                chapterId: chapterId,
                                bValue: bValue,
                                rowIndex: row
                            });
                        }
                    }
                }
            }
            
            return stageData;
        }

        let processedWorkbook = null; // å­˜å‚¨å¤„ç†åçš„å·¥ä½œç°¿

        // ç¬¬äºŒéƒ¨åˆ†ï¼šæ•°æ®å¤„ç† - æ ¹æ®è§„åˆ™ç”Ÿæˆæ€ªç‰©ç»„æ•°æ®
        function processData() {
            if (!workbookData) {
                alert('è¯·å…ˆä¸Šä¼ æ–‡ä»¶');
                return;
            }

            // æ‰¾åˆ°"å…³å¡è§„åˆ’æ€»"sheeté¡µ
            let planSheet = null;
            let planSheetName = null;
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('å…³å¡è§„åˆ’æ€»') || sheetName.includes('è§„åˆ’æ€»')) {
                    planSheet = workbookData.Sheets[sheetName];
                    planSheetName = sheetName;
                    break;
                }
            }

            if (!planSheet) {
                alert('æœªæ‰¾åˆ°"å…³å¡è§„åˆ’æ€»"sheeté¡µ');
                return;
            }

            // æ‰¾åˆ°"æ€ªç‰©ç»„"sheeté¡µ
            let monsterGroupSheet = null;
            let monsterGroupSheetName = null;
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('æ€ªç‰©ç»„')) {
                    monsterGroupSheet = workbookData.Sheets[sheetName];
                    monsterGroupSheetName = sheetName;
                    break;
                }
            }

            if (!monsterGroupSheet) {
                alert('æœªæ‰¾åˆ°"æ€ªç‰©ç»„"sheeté¡µ');
                return;
            }

            // è¯»å–"å…³å¡è§„åˆ’æ€»"æ•°æ®
            const planData = XLSX.utils.sheet_to_json(planSheet, { header: 1, defval: '' });
            if (planData.length === 0) {
                alert('"å…³å¡è§„åˆ’æ€»"sheeté¡µä¸ºç©º');
                return;
            }
            
            // ä¿å­˜åŸå§‹æ•°æ®ä¾›å¯¼å‡ºä½¿ç”¨
            globalPlanData = {
                data: planData,
                sheetName: planSheetName,
                headerRow: planData.length > 0 ? planData[0] : []
            };

            // æŸ¥æ‰¾åˆ—ç´¢å¼•
            const headerRow = planData[0];
            let chapterColIndex = -1; // ç« èŠ‚åˆ—
            let stageSeqColIndex = -1; // å°å…³åºå·åˆ—
            let monsterCountColIndex = -1; // æ€ªç‰©æ•°é‡åˆ—
            let stageTypeColIndex = -1; // å…³å¡ç±»å‹åˆ—
            let bossEliteColIndex = -1; // bosså’Œç²¾è‹±åˆ—

            for (let i = 0; i < headerRow.length; i++) {
                const header = String(headerRow[i]).trim();
                if (header.includes('ç« èŠ‚') || header === 'ç« èŠ‚') {
                    chapterColIndex = i;
                }
                if (header.includes('å°å…³åºå·') || header === 'å°å…³åºå·' || header.includes('åºå·')) {
                    stageSeqColIndex = i;
                }
                if (header.includes('æ€ªç‰©æ•°é‡') || header === 'æ€ªç‰©æ•°é‡' || header.includes('æ•°é‡')) {
                    monsterCountColIndex = i;
                }
                if (header.includes('å…³å¡ç±»å‹') || header === 'å…³å¡ç±»å‹' || header.includes('ç±»å‹')) {
                    stageTypeColIndex = i;
                }
                if (header.includes('bosså’Œç²¾è‹±') || header === 'bosså’Œç²¾è‹±' || (header.includes('boss') && header.includes('ç²¾è‹±'))) {
                    bossEliteColIndex = i;
                }
            }

            if (chapterColIndex === -1 || stageSeqColIndex === -1 || monsterCountColIndex === -1) {
                alert('æœªæ‰¾åˆ°å¿…è¦çš„åˆ—ï¼šç« èŠ‚ã€å°å…³åºå·ã€æ€ªç‰©æ•°é‡');
                console.log('ç« èŠ‚åˆ—:', chapterColIndex, 'å°å…³åºå·åˆ—:', stageSeqColIndex, 'æ€ªç‰©æ•°é‡åˆ—:', monsterCountColIndex);
                return;
            }

            // è¯»å–"æ€ªç‰©ç»„"æ•°æ®
            const monsterGroupData = XLSX.utils.sheet_to_json(monsterGroupSheet, { header: 1, defval: '' });
            
            // æŸ¥æ‰¾"ç« èŠ‚æ€»"sheeté¡µï¼Œå»ºç«‹ç« èŠ‚IDä¸ä¸»é¢˜ã€æ€ªç‰©æƒé‡çš„æ˜ å°„å…³ç³»
            let chapterTotalSheet = null;
            let chapterThemeMap = {}; // ç« èŠ‚IDåˆ°ä¸»é¢˜çš„æ˜ å°„
            let chapterWeightMap = {}; // ç« èŠ‚IDåˆ°æ€ªç‰©æƒé‡çš„æ˜ å°„
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('ç« èŠ‚æ€»') || sheetName.includes('æ€»è¡¨')) {
                    chapterTotalSheet = workbookData.Sheets[sheetName];
                    break;
                }
            }
            
            if (chapterTotalSheet) {
                const chapterTotalData = XLSX.utils.sheet_to_json(chapterTotalSheet, { header: 1, defval: '' });
                if (chapterTotalData.length > 0) {
                    const chapterTotalHeader = chapterTotalData[0];
                    let chapterIdColInTotal = -1; // ç« èŠ‚æ€»ä¸­çš„ç« èŠ‚IDåˆ—
                    let themeColInTotal = -1; // ç« èŠ‚æ€»ä¸­çš„ä¸»é¢˜åˆ—
                    let weightColInTotal = -1; // ç« èŠ‚æ€»ä¸­çš„æ€ªç‰©æƒé‡åˆ—
                    
                    for (let i = 0; i < chapterTotalHeader.length; i++) {
                        const header = String(chapterTotalHeader[i]).trim();
                        const headerLower = header.toLowerCase();
                        if ((header.includes('ç« èŠ‚') && header.includes('ID')) || headerLower.includes('ç« èŠ‚id') || header === 'ç« èŠ‚ID' || header === 'ç« èŠ‚id') {
                            chapterIdColInTotal = i;
                        }
                        if (header.includes('ä¸»é¢˜') || header === 'ä¸»é¢˜') {
                            themeColInTotal = i;
                        }
                        if (header.includes('æ€ªç‰©æƒé‡') || header === 'æ€ªç‰©æƒé‡' || header.includes('æƒé‡')) {
                            weightColInTotal = i;
                        }
                    }
                    
                    // å¦‚æœæ‰¾åˆ°äº†ç« èŠ‚IDåˆ—å’Œä¸»é¢˜åˆ—ï¼Œå»ºç«‹æ˜ å°„å…³ç³»
                    if (chapterIdColInTotal >= 0 && themeColInTotal >= 0) {
                        for (let row = 1; row < chapterTotalData.length; row++) {
                            const chapterId = chapterTotalData[row][chapterIdColInTotal];
                            const theme = chapterTotalData[row][themeColInTotal];
                            const weight = weightColInTotal >= 0 ? chapterTotalData[row][weightColInTotal] : '';
                            if (chapterId !== '' && chapterId !== null && chapterId !== undefined) {
                                const numChapterId = Number(chapterId);
                                if (!isNaN(numChapterId)) {
                                    chapterThemeMap[numChapterId] = theme || '';
                                    chapterWeightMap[numChapterId] = weight || '';
                                }
                            }
                        }
                    }
                }
            }
            
            // æŸ¥æ‰¾"æ€ªç‰©åˆ†å¸ƒ"sheeté¡µ
            let monsterDistributionSheet = null;
            let monsterDistributionData = [];
            let monsterDistributionHeader = [];
            let monsterIdColInDistribution = -1; // æ€ªç‰©åˆ†å¸ƒä¸­çš„æ€ªç‰©IDåˆ—
            let themeColInDistribution = -1; // æ€ªç‰©åˆ†å¸ƒä¸­çš„ä¸»é¢˜åˆ—
            let stageTypeColInDistribution = -1; // æ€ªç‰©åˆ†å¸ƒä¸­çš„å…³å¡ç±»å‹åˆ—
            let tagColInDistribution = -1; // æ€ªç‰©åˆ†å¸ƒä¸­çš„æ ‡ç­¾åˆ—
            
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('æ€ªç‰©åˆ†å¸ƒ')) {
                    monsterDistributionSheet = workbookData.Sheets[sheetName];
                    break;
                }
            }
            
            if (monsterDistributionSheet) {
                monsterDistributionData = XLSX.utils.sheet_to_json(monsterDistributionSheet, { header: 1, defval: '' });
                if (monsterDistributionData.length > 0) {
                    monsterDistributionHeader = monsterDistributionData[0];
                    
                    for (let i = 0; i < monsterDistributionHeader.length; i++) {
                        const header = String(monsterDistributionHeader[i]).trim();
                        const headerLower = header.toLowerCase();
                        if ((header.includes('æ€ªç‰©') && header.includes('ID')) || headerLower.includes('æ€ªç‰©id') || header === 'æ€ªç‰©ID' || header === 'æ€ªç‰©id') {
                            monsterIdColInDistribution = i;
                        }
                        if (header.includes('ä¸»é¢˜') || header === 'ä¸»é¢˜') {
                            themeColInDistribution = i;
                        }
                        if (header.includes('å…³å¡ç±»å‹') || header === 'å…³å¡ç±»å‹') {
                            stageTypeColInDistribution = i;
                        }
                        if (header.includes('æ ‡ç­¾') || header === 'æ ‡ç­¾') {
                            tagColInDistribution = i;
                        }
                    }
                }
            }
            
            // æŸ¥æ‰¾"æ•Œäººç«™ä½"sheeté¡µ
            let enemyPositionSheet = null;
            let enemyPositionData = [];
            let enemyPositionHeader = [];
            let monsterCountColInPosition = -1; // æ•Œäººç«™ä½ä¸­çš„æ€ªç‰©æ•°é‡åˆ—
            let positionIdColInPosition = -1; // æ•Œäººç«™ä½ä¸­çš„ç«™ä½idåˆ—
            
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('æ•Œäººç«™ä½') || sheetName.includes('ç«™ä½')) {
                    enemyPositionSheet = workbookData.Sheets[sheetName];
                    break;
                }
            }
            
            if (enemyPositionSheet) {
                enemyPositionData = XLSX.utils.sheet_to_json(enemyPositionSheet, { header: 1, defval: '' });
                if (enemyPositionData.length > 0) {
                    enemyPositionHeader = enemyPositionData[0];
                    console.log('æ•Œäººç«™ä½è¡¨å¤´:', enemyPositionHeader);
                    
                    for (let i = 0; i < enemyPositionHeader.length; i++) {
                        const header = String(enemyPositionHeader[i]).trim();
                        const headerLower = header.toLowerCase();
                        if (header.includes('æ€ªç‰©æ•°é‡') || header === 'æ€ªç‰©æ•°é‡' || header.includes('æ•°é‡')) {
                            monsterCountColInPosition = i;
                        }
                        if ((header.includes('ç«™ä½') && header.includes('ID')) || headerLower.includes('ç«™ä½id') || header === 'ç«™ä½ID' || header === 'ç«™ä½id') {
                            positionIdColInPosition = i;
                        }
                    }
                    console.log('æ•Œäººç«™ä½åˆ—ç´¢å¼•:', {
                        monsterCountCol: monsterCountColInPosition,
                        positionIdCol: positionIdColInPosition
                    });
                }
            } else {
                console.log('æœªæ‰¾åˆ°æ•Œäººç«™ä½sheeté¡µ');
            }
            
            // æŸ¥æ‰¾"æ€ªç‰©ç»„"sheeté¡µçš„åˆ—ç´¢å¼•
            const monsterHeaderRow = monsterGroupData.length > 0 ? monsterGroupData[0] : [];
            let enemyGroupIdColIndex = -1; // æ•Œäººç»„IDåˆ—
            let uniqueIdColIndex = -1; // å”¯ä¸€IDåˆ—
            let chapterColInMonsterGroup = -1; // ç« èŠ‚åˆ—
            let stageTypeColInMonsterGroup = -1; // å…³å¡ç±»å‹åˆ—
            let themeColInMonsterGroup = -1; // ä¸»é¢˜åˆ—
            let enemyIdColInMonsterGroup = -1; // æ•ŒäººIDåˆ—
            let positionColInMonsterGroup = -1; // ç«™ä½åˆ—
            let stageSeqColInMonsterGroup = -1; // å°å…³åºå·åˆ—
            let hpTimesColInMonsterGroup = -1; // æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´åˆ—
            let atkTimesColInMonsterGroup = -1; // æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´åˆ—
            
            for (let i = 0; i < monsterHeaderRow.length; i++) {
                const header = String(monsterHeaderRow[i]).trim();
                const headerLower = header.toLowerCase();
                if (header.includes('æ•Œäººç»„ID') || header === 'æ•Œäººç»„ID' || headerLower.includes('æ•Œäººç»„id')) {
                    enemyGroupIdColIndex = i;
                }
                if (header.includes('å”¯ä¸€ID') || header === 'å”¯ä¸€ID' || headerLower.includes('å”¯ä¸€id') || header === 'å”¯ä¸€id') {
                    uniqueIdColIndex = i;
                }
                if (header.includes('ç« èŠ‚') && !header.includes('ID') && !headerLower.includes('id')) {
                    chapterColInMonsterGroup = i;
                }
                if (header.includes('å…³å¡ç±»å‹') || header === 'å…³å¡ç±»å‹') {
                    stageTypeColInMonsterGroup = i;
                }
                if (header.includes('ä¸»é¢˜') || header === 'ä¸»é¢˜') {
                    themeColInMonsterGroup = i;
                }
                if ((header.includes('æ•Œäºº') && header.includes('ID') && !header.includes('ç»„')) || (headerLower.includes('æ•Œäººid') && !headerLower.includes('ç»„')) || header === 'æ•ŒäººID' || header === 'æ•Œäººid') {
                    enemyIdColInMonsterGroup = i;
                }
                if (header.includes('ç«™ä½') && !header.includes('ID') && !headerLower.includes('id')) {
                    positionColInMonsterGroup = i;
                }
                if (header.includes('å°å…³åºå·') || header === 'å°å…³åºå·' || (header.includes('åºå·') && !header.includes('å”¯ä¸€'))) {
                    stageSeqColInMonsterGroup = i;
                }
                if (header.includes('æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´') || header === 'æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´' || header.includes('è¡€é‡å€ç‡')) {
                    hpTimesColInMonsterGroup = i;
                }
                if (header.includes('æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´') || header === 'æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´' || header.includes('æ”»å‡»åŠ›å€ç‡')) {
                    atkTimesColInMonsterGroup = i;
                }
            }

            if (enemyGroupIdColIndex === -1) {
                console.log('æ€ªç‰©ç»„è¡¨å¤´:', monsterHeaderRow);
                alert('æœªæ‰¾åˆ°"æ•Œäººç»„ID"åˆ—ï¼Œè¯·æ£€æŸ¥åˆ—åæ˜¯å¦æ­£ç¡®');
                return;
            }
            if (uniqueIdColIndex === -1) {
                console.log('æ€ªç‰©ç»„è¡¨å¤´:', monsterHeaderRow);
                alert('æœªæ‰¾åˆ°"å”¯ä¸€ID"åˆ—ï¼Œè¯·æ£€æŸ¥åˆ—åæ˜¯å¦æ­£ç¡®ã€‚å½“å‰è¡¨å¤´ï¼š' + JSON.stringify(monsterHeaderRow));
                return;
            }

            // åŠ æƒéšæœºé€‰æ‹©å‡½æ•°
            function weightedRandomSelect(items, weights) {
                if (items.length === 0) return null;
                if (items.length !== weights.length) {
                    // å¦‚æœæƒé‡æ•°ç»„é•¿åº¦ä¸åŒ¹é…ï¼Œä½¿ç”¨å‡åŒ€æƒé‡
                    const index = Math.floor(Math.random() * items.length);
                    return items[index];
                }
                // è®¡ç®—æ€»æƒé‡
                const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                if (totalWeight <= 0) {
                    // å¦‚æœæ€»æƒé‡ä¸º0æˆ–è´Ÿæ•°ï¼Œä½¿ç”¨å‡åŒ€éšæœº
                    const index = Math.floor(Math.random() * items.length);
                    return items[index];
                }
                // ç”Ÿæˆéšæœºæ•°
                let random = Math.random() * totalWeight;
                // æ ¹æ®æƒé‡é€‰æ‹©
                for (let i = 0; i < items.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        return items[i];
                    }
                }
                // å¦‚æœå¾ªç¯ç»“æŸè¿˜æ²¡è¿”å›ï¼Œè¿”å›æœ€åä¸€ä¸ª
                return items[items.length - 1];
            }

            // è§£ææƒé‡å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "Common*30|Fly*30|Tank*40"
            function parseWeightString(weightStr) {
                const weightMap = {};
                if (!weightStr || weightStr === '') return weightMap;
                const parts = weightStr.split('|');
                for (let part of parts) {
                    const match = part.match(/^(.+?)\*(\d+)$/);
                    if (match) {
                        const tag = match[1].trim();
                        const weight = parseInt(match[2], 10);
                        weightMap[tag] = weight;
                    }
                }
                return weightMap;
            }

            // æ ¹æ®ä¸»é¢˜ã€å…³å¡ç±»å‹å’Œæƒé‡é€‰æ‹©æ€ªç‰©ID
            function selectMonsterId(theme, stageType, weightStr) {
                if (!monsterDistributionSheet || monsterDistributionData.length === 0) {
                    console.log('æœªæ‰¾åˆ°æ€ªç‰©åˆ†å¸ƒsheeté¡µæˆ–æ•°æ®ä¸ºç©º');
                    return '';
                }
                
                // æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°äº†å¿…è¦çš„åˆ—
                if (monsterIdColInDistribution < 0 || themeColInDistribution < 0 || stageTypeColInDistribution < 0) {
                    console.log('æ€ªç‰©åˆ†å¸ƒè¡¨ç¼ºå°‘å¿…è¦çš„åˆ—:', {
                        monsterIdCol: monsterIdColInDistribution,
                        themeCol: themeColInDistribution,
                        stageTypeCol: stageTypeColInDistribution
                    });
                    return '';
                }
                
                // ç­›é€‰ç¬¦åˆæ¡ä»¶çš„æ€ªç‰©ï¼šä¸»é¢˜åŒ¹é…ä¸”å…³å¡ç±»å‹åŒ¹é…
                const candidates = [];
                for (let row = 1; row < monsterDistributionData.length; row++) {
                    const monsterTheme = String(monsterDistributionData[row][themeColInDistribution] || '').trim();
                    const monsterStageType = String(monsterDistributionData[row][stageTypeColInDistribution] || '').trim();
                    const monsterTag = tagColInDistribution >= 0 ? String(monsterDistributionData[row][tagColInDistribution] || '').trim() : '';
                    const monsterId = monsterDistributionData[row][monsterIdColInDistribution];
                    
                    // æ£€æŸ¥ä¸»é¢˜æ˜¯å¦åŒ¹é…
                    if (monsterTheme !== theme) continue;
                    if (monsterId === '' || monsterId === null || monsterId === undefined) continue;
                    
                    // æ£€æŸ¥å…³å¡ç±»å‹æ˜¯å¦åŒ¹é…ï¼ˆæ”¯æŒ"1*4"è¿™ç§æ ¼å¼ï¼Œè¡¨ç¤º1æˆ–4éƒ½å¯ä»¥ï¼‰
                    let stageTypeMatch = false;
                    if (monsterStageType.includes('*')) {
                        // å¦‚æœåŒ…å«"*"ï¼Œæ‹†åˆ†ä¸ºå¤šä¸ªå€¼è¿›è¡ŒåŒ¹é…
                        const stageTypeValues = monsterStageType.split('*').map(v => String(v).trim());
                        stageTypeMatch = stageTypeValues.includes(stageType);
                    } else {
                        // å¦åˆ™ä½¿ç”¨ç²¾ç¡®åŒ¹é…
                        stageTypeMatch = monsterStageType === stageType;
                    }
                    
                    if (stageTypeMatch) {
                        candidates.push({
                            id: monsterId,
                            tag: monsterTag
                        });
                    }
                }
                
                if (candidates.length === 0) {
                    console.log('æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æ€ªç‰©:', { theme, stageType, weightStr });
                    return '';
                }
                
                // å¦‚æœæ²¡æœ‰æƒé‡å­—ç¬¦ä¸²ï¼Œä½¿ç”¨å‡åŒ€éšæœº
                if (!weightStr || weightStr === '') {
                    const randomIndex = Math.floor(Math.random() * candidates.length);
                    return candidates[randomIndex].id;
                }
                
                // è§£ææƒé‡å­—ç¬¦ä¸²
                const weightMap = parseWeightString(weightStr);
                
                // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„æƒé‡æ˜ å°„ï¼Œä½¿ç”¨å‡åŒ€éšæœº
                if (Object.keys(weightMap).length === 0) {
                    const randomIndex = Math.floor(Math.random() * candidates.length);
                    return candidates[randomIndex].id;
                }
                
                // æŒ‰æ ‡ç­¾åˆ†ç»„
                const tagGroups = {};
                for (let candidate of candidates) {
                    const tag = candidate.tag || '';
                    if (!tagGroups[tag]) {
                        tagGroups[tag] = [];
                    }
                    tagGroups[tag].push(candidate.id);
                }
                
                // æ ¹æ®æƒé‡é€‰æ‹©æ ‡ç­¾
                const tags = Object.keys(tagGroups);
                const tagWeights = tags.map(tag => weightMap[tag] || 0);
                const selectedTag = weightedRandomSelect(tags, tagWeights);
                
                if (!selectedTag || !tagGroups[selectedTag] || tagGroups[selectedTag].length === 0) {
                    // å¦‚æœé€‰æ‹©çš„æ ‡ç­¾æ²¡æœ‰å¯¹åº”çš„æ€ªç‰©ï¼Œä½¿ç”¨å‡åŒ€éšæœº
                    const randomIndex = Math.floor(Math.random() * candidates.length);
                    return candidates[randomIndex].id;
                }
                
                // åœ¨é€‰ä¸­çš„æ ‡ç­¾ç»„ä¸­å‡åŒ€éšæœºé€‰æ‹©ä¸€ä¸ª
                const selectedGroup = tagGroups[selectedTag];
                const randomIndex = Math.floor(Math.random() * selectedGroup.length);
                return selectedGroup[randomIndex];
            }

            // è·å–å¤„ç†é€‰é¡¹
            const processOption = document.querySelector('input[name="processOption"]:checked');
            const processType = processOption ? processOption.value : 'all';
            let targetChapterId = null;
            
            // å¦‚æœæ˜¯åˆ†ç« èŠ‚ç”Ÿæˆï¼Œè·å–ç« èŠ‚ID
            if (processType === 'single') {
                const singleChapterProcessIdInput = document.getElementById('singleChapterProcessId');
                const inputValue = singleChapterProcessIdInput ? singleChapterProcessIdInput.value : null;
                if (!inputValue || inputValue === '') {
                    alert('è¯·è¾“å…¥ç« èŠ‚ID');
                    return;
                }
                targetChapterId = Number(inputValue);
                if (isNaN(targetChapterId) || targetChapterId <= 0) {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ç« èŠ‚ID');
                    return;
                }
            }

            // ç”Ÿæˆæ•°æ®ï¼šæ ¹æ®è§„åˆ™å¡«å……"æ•Œäººç»„ID"åˆ—ï¼ˆä»ç¬¬äºŒè¡Œå¼€å§‹ï¼‰
            // åŒæ—¶æŒ‰ç« èŠ‚IDåˆ†ç»„è®¡æ•°ï¼Œç”Ÿæˆå”¯ä¸€ID
            const generatedData = []; // å¯¹è±¡æ•°ç»„ï¼ŒåŒ…å«enemyGroupIdã€chapterIdã€uniqueIdã€stageTypeã€themeå’ŒenemyId
            const chapterCounters = {}; // æ¯ä¸ªç« èŠ‚çš„è®¡æ•°å™¨ï¼Œç”¨äºç”Ÿæˆå”¯ä¸€ID
            
            // éå†"å…³å¡è§„åˆ’æ€»"çš„æ¯ä¸€è¡Œï¼ˆä»ç¬¬äºŒè¡Œå¼€å§‹ï¼Œç´¢å¼•1ï¼‰
            for (let row = 1; row < planData.length; row++) {
                const chapter = planData[row][chapterColIndex];
                const stageSeq = planData[row][stageSeqColIndex];
                const monsterCount = planData[row][monsterCountColIndex];
                const stageType = stageTypeColIndex >= 0 ? planData[row][stageTypeColIndex] : '';
                const bossElite = bossEliteColIndex >= 0 ? planData[row][bossEliteColIndex] : '';

                // éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
                if (chapter === '' || chapter === null || chapter === undefined) continue;
                
                // å¦‚æœæ˜¯åˆ†ç« èŠ‚ç”Ÿæˆï¼Œåªå¤„ç†æŒ‡å®šç« èŠ‚çš„æ•°æ®
                if (processType === 'single') {
                    const numChapter = Number(chapter);
                    if (isNaN(numChapter) || numChapter !== targetChapterId) {
                        continue; // è·³è¿‡ä¸æ˜¯ç›®æ ‡ç« èŠ‚çš„è¡Œ
                    }
                }
                if (stageSeq === '' || stageSeq === null || stageSeq === undefined) continue;
                const numMonsterCount = Number(monsterCount);
                if (isNaN(numMonsterCount) || numMonsterCount <= 0) continue;

                // è®¡ç®—å€¼ï¼šå°å…³åºå· * 100 + 1
                const numStageSeq = Number(stageSeq);
                if (isNaN(numStageSeq)) continue;
                
                const enemyGroupId = numStageSeq * 100 + 1;
                const numChapter = Number(chapter);
                if (isNaN(numChapter)) continue;

                // ä»ç« èŠ‚æ€»ä¸­è·å–è¯¥ç« èŠ‚çš„ä¸»é¢˜å’Œæƒé‡
                const theme = String(chapterThemeMap[numChapter] || '').trim();
                const weightStr = String(chapterWeightMap[numChapter] || '').trim();
                // å°†stageTypeè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç¡®ä¿åŒ¹é…
                const stageTypeStr = stageType !== '' && stageType !== null && stageType !== undefined ? String(stageType).trim() : '';
                // ç¡®ä¿stageTypeæ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼Œç”¨äºåç»­å¡«å……
                const stageTypeValue = stageType !== '' && stageType !== null && stageType !== undefined ? String(stageType).trim() : '';
                // ç¡®ä¿stageSeqæ˜¯æ•°å­—æ ¼å¼ï¼Œç”¨äºåç»­å¡«å……ï¼ˆåŒä¸€enemyGroupIdçš„æ‰€æœ‰è®°å½•ä½¿ç”¨ç›¸åŒçš„å°å…³åºå·ï¼‰
                const stageSeqValue = numStageSeq;
                
                // æ ¹æ®è§„åˆ™è®¡ç®—æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´å’Œæ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´
                // è§„åˆ™ï¼šå¦‚æœå…³å¡ç±»å‹ä¸º1æˆ–4ï¼Œä¸”ç« èŠ‚IDä¸º1ï¼Œåˆ™å¡«å…¥"1*1"
                //       å¦‚æœå…³å¡ç±»å‹ä¸º1æˆ–4ï¼Œä½†ç« èŠ‚IDä¸ä¸º1ï¼Œåˆ™å¡«å…¥"0.95*1.05"
                //       å¦‚æœå…³å¡ç±»å‹ä¸ä¸º1æˆ–4ï¼Œåˆ™å¡«å…¥"1*1"
                const numStageType = Number(stageTypeValue);
                let hpTimesValue = '1*1'; // é»˜è®¤å€¼
                let atkTimesValue = '1*1'; // é»˜è®¤å€¼
                if (!isNaN(numStageType) && (numStageType === 1 || numStageType === 4)) {
                    // å…³å¡ç±»å‹ä¸º1æˆ–4
                    if (numChapter === 1) {
                        // ç« èŠ‚IDä¸º1
                        hpTimesValue = '1*1';
                        atkTimesValue = '1*1';
                    } else {
                        // ç« èŠ‚IDä¸ä¸º1
                        hpTimesValue = '0.95*1.05';
                        atkTimesValue = '0.95*1.05';
                    }
                } else {
                    // å…³å¡ç±»å‹ä¸ä¸º1æˆ–4
                    hpTimesValue = '1*1';
                    atkTimesValue = '1*1';
                }

                // åˆå§‹åŒ–è¯¥ç« èŠ‚çš„è®¡æ•°å™¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                if (!chapterCounters[numChapter]) {
                    chapterCounters[numChapter] = 0;
                }

                // æ ¹æ®"æ€ªç‰©æ•°é‡"é‡å¤å¡«å†™ç›¸åº”æ¬¡æ•°
                // åœ¨ç”Ÿæˆ"æ•Œäººç»„ID"çš„åŒæ—¶ï¼ŒæŒ‰ç« èŠ‚IDåˆ†ç»„è®¡æ•°ç”Ÿæˆ"å”¯ä¸€ID"ï¼Œå¹¶æ ¹æ®è§„åˆ™éšæœºé€‰æ‹©æ€ªç‰©ID
                // æ³¨æ„ï¼šåŒä¸€ä¸ªenemyGroupIdçš„æ‰€æœ‰è®°å½•ï¼ŒstageTypeã€themeã€stageSeqã€hpTimeså’ŒatkTimesåº”è¯¥ä¿æŒä¸€è‡´ï¼ˆéƒ½ä½¿ç”¨å½“å‰è¡Œçš„å€¼ï¼‰
                for (let i = 0; i < numMonsterCount; i++) {
                    // è®¡æ•°å™¨åŠ 1ï¼Œç”Ÿæˆå”¯ä¸€ID
                    chapterCounters[numChapter]++;
                    const uniqueId = chapterCounters[numChapter];
                    
                    // æ ¹æ®å…³å¡ç±»å‹é€‰æ‹©æ€ªç‰©ID
                    // å¦‚æœå…³å¡ç±»å‹ä¸æ˜¯1æˆ–4ï¼Œä½¿ç”¨"bosså’Œç²¾è‹±"åˆ—çš„å€¼
                    // å¦‚æœå…³å¡ç±»å‹æ˜¯1æˆ–4ï¼Œä½¿ç”¨éšæœºé€‰æ‹©é€»è¾‘
                    let enemyId = '';
                    if (!isNaN(numStageType) && (numStageType === 1 || numStageType === 4)) {
                        // å…³å¡ç±»å‹ä¸º1æˆ–4ï¼Œä½¿ç”¨éšæœºé€‰æ‹©é€»è¾‘
                        enemyId = selectMonsterId(theme, stageTypeStr, weightStr);
                    } else {
                        // å…³å¡ç±»å‹ä¸æ˜¯1æˆ–4ï¼Œä½¿ç”¨"bosså’Œç²¾è‹±"åˆ—çš„å€¼
                        enemyId = bossElite !== '' && bossElite !== null && bossElite !== undefined ? String(bossElite).trim() : '';
                    }
                    
                    generatedData.push({
                        enemyGroupId: enemyGroupId,
                        chapterId: numChapter,
                        uniqueId: uniqueId,
                        stageType: stageTypeValue, // ä½¿ç”¨ç»Ÿä¸€çš„stageTypeValueï¼Œç¡®ä¿åŒä¸€enemyGroupIdçš„è®°å½•ä¸€è‡´
                        theme: theme, // ä½¿ç”¨ç»Ÿä¸€çš„themeï¼Œç¡®ä¿åŒä¸€enemyGroupIdçš„è®°å½•ä¸€è‡´
                        stageSeq: stageSeqValue, // ä½¿ç”¨ç»Ÿä¸€çš„stageSeqValueï¼Œç¡®ä¿åŒä¸€enemyGroupIdçš„è®°å½•ä¸€è‡´
                        hpTimes: hpTimesValue, // ä½¿ç”¨ç»Ÿä¸€çš„hpTimesValueï¼Œç¡®ä¿åŒä¸€enemyGroupIdçš„è®°å½•ä¸€è‡´
                        atkTimes: atkTimesValue, // ä½¿ç”¨ç»Ÿä¸€çš„atkTimesValueï¼Œç¡®ä¿åŒä¸€enemyGroupIdçš„è®°å½•ä¸€è‡´
                        enemyId: enemyId,
                        monsterCount: numMonsterCount, // è®°å½•æ€ªç‰©æ•°é‡ï¼Œç”¨äºåç»­åˆ†é…ç«™ä½
                        position: '' // ç«™ä½ï¼Œç¨ååˆ†é…
                    });
                }
            }
            
            // æ ¹æ®"æ•Œäººç«™ä½"è¡¨åˆ†é…ç«™ä½
            // æŒ‰"æ•Œäººç»„ID"åˆ†ç»„ï¼Œä¸ºæ¯ç»„åˆ†é…ç«™ä½
            function getPositionIdByMonsterCount(count) {
                if (!enemyPositionSheet || enemyPositionData.length === 0) {
                    console.log(`æ€ªç‰©æ•°é‡${count}: æœªæ‰¾åˆ°"æ•Œäººç«™ä½"sheeté¡µæˆ–æ•°æ®ä¸ºç©º`);
                    return '';
                }
                if (monsterCountColInPosition < 0 || positionIdColInPosition < 0) {
                    console.log(`æ€ªç‰©æ•°é‡${count}: æœªæ‰¾åˆ°å¿…è¦çš„åˆ—ï¼ˆæ€ªç‰©æ•°é‡åˆ—: ${monsterCountColInPosition}, ç«™ä½idåˆ—: ${positionIdColInPosition}ï¼‰`);
                    return '';
                }
                
                // æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„è¡Œ
                const matchingRows = [];
                for (let row = 1; row < enemyPositionData.length; row++) {
                    const rowMonsterCount = Number(enemyPositionData[row][monsterCountColInPosition]);
                    if (!isNaN(rowMonsterCount) && rowMonsterCount === count) {
                        const positionId = String(enemyPositionData[row][positionIdColInPosition] || '').trim();
                        if (positionId !== '') {
                            matchingRows.push(positionId);
                        }
                    }
                }
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„è¡Œï¼Œéšæœºé€‰æ‹©ä¸€è¡Œ
                if (matchingRows.length > 0) {
                    const randomIndex = Math.floor(Math.random() * matchingRows.length);
                    console.log(`æ€ªç‰©æ•°é‡${count}: æ‰¾åˆ°${matchingRows.length}ä¸ªåŒ¹é…çš„ç«™ä½idï¼Œéšæœºé€‰æ‹©: ${matchingRows[randomIndex]}`);
                    return matchingRows[randomIndex];
                }
                
                console.log(`æ€ªç‰©æ•°é‡${count}: åœ¨"æ•Œäººç«™ä½"è¡¨ä¸­æœªæ‰¾åˆ°åŒ¹é…çš„æ€ªç‰©æ•°é‡`);
                return '';
            }
            
            // åˆ†é…ç«™ä½ï¼šç¡®ä¿ç›¸é‚»è¡Œä¸é‡å¤
            function assignPositions(groupData, monsterCount) {
                if (groupData.length === 0) return;
                if (monsterCount <= 0) return;
                
                // ä»"æ•Œäººç«™ä½"è¡¨ä¸­è·å–ç«™ä½id
                const positionIdStr = getPositionIdByMonsterCount(monsterCount);
                if (!positionIdStr || positionIdStr === '') return;
                
                // æ‹†åˆ†ç«™ä½idï¼ˆä¾‹å¦‚"501*502*503"æ‹†åˆ†ä¸º[501, 502, 503]ï¼‰
                const positionIds = positionIdStr.split('*').map(v => String(v).trim()).filter(v => v !== '');
                if (positionIds.length === 0) return;
                
                // åˆ†é…ç«™ä½ï¼Œç¡®ä¿æ‰€æœ‰æ•°æ®éƒ½ä¸é‡å¤
                // ä½¿ç”¨groupData.lengthè€Œä¸æ˜¯monsterCountï¼Œå› ä¸ºgroupData.lengthæ˜¯å®é™…éœ€è¦åˆ†é…çš„è¡Œæ•°
                const needCount = groupData.length;
                if (positionIds.length >= needCount) {
                    // å¦‚æœæ‹†åˆ†åçš„æ•°é‡å¤§äºç­‰äºéœ€è¦åˆ†é…çš„æ•°é‡ï¼Œå–å‰needCountä¸ªï¼Œæ‰“ä¹±é¡ºåºååˆ†é…
                    const shuffledPositions = positionIds.slice(0, needCount);
                    // æ‰“ä¹±é¡ºåºï¼ˆFisher-Yatesæ´—ç‰Œç®—æ³•ï¼‰
                    for (let i = shuffledPositions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledPositions[i], shuffledPositions[j]] = [shuffledPositions[j], shuffledPositions[i]];
                    }
                    // æŒ‰æ‰“ä¹±åçš„é¡ºåºåˆ†é…
                    for (let i = 0; i < groupData.length; i++) {
                        groupData[i].position = shuffledPositions[i];
                    }
                } else {
                    // å¦‚æœæ‹†åˆ†åçš„æ•°é‡å°äºéœ€è¦åˆ†é…çš„æ•°é‡ï¼Œå¾ªç¯ä½¿ç”¨
                    for (let i = 0; i < groupData.length; i++) {
                        groupData[i].position = positionIds[i % positionIds.length];
                    }
                }
            }
            
            // æŒ‰"æ•Œäººç»„ID"+"æ€ªç‰©æ•°é‡"åˆ†ç»„ï¼Œä¸ºæ¯ç»„åˆ†é…ç«™ä½
            // ä½¿ç”¨ç»„åˆé”®ï¼šenemyGroupId + "_" + monsterCount
            const enemyGroupMap = {}; // {enemyGroupId_monsterCount: [data1, data2, ...], ...}
            for (let i = 0; i < generatedData.length; i++) {
                const enemyGroupId = generatedData[i].enemyGroupId;
                const monsterCount = generatedData[i].monsterCount;
                const groupKey = enemyGroupId + "_" + monsterCount;
                if (!enemyGroupMap[groupKey]) {
                    enemyGroupMap[groupKey] = [];
                }
                enemyGroupMap[groupKey].push(generatedData[i]);
            }
            
            // ä¸ºæ¯ç»„åˆ†é…ç«™ä½
            for (let groupKey in enemyGroupMap) {
                const groupData = enemyGroupMap[groupKey];
                // ç›´æ¥ä»groupDataä¸­è·å–monsterCountï¼Œå› ä¸ºæ‰€æœ‰æ•°æ®çš„monsterCountéƒ½ç›¸åŒ
                if (groupData.length > 0 && groupData[0].monsterCount) {
                    const monsterCount = groupData[0].monsterCount;
                    console.log(`ä¸ºç»„åˆ†é…ç«™ä½: groupKey=${groupKey}, groupData.length=${groupData.length}, monsterCount=${monsterCount}`);
                    assignPositions(groupData, monsterCount);
                } else {
                    console.log(`ç»„æ•°æ®æ— æ•ˆ: groupKey=${groupKey}, groupData.length=${groupData.length}`);
                }
            }

            // åˆ›å»ºå¤„ç†åçš„å·¥ä½œç°¿ï¼ˆå¤åˆ¶åŸå·¥ä½œç°¿ï¼‰
            processedWorkbook = XLSX.utils.book_new();
            workbookData.SheetNames.forEach(sheetName => {
                const originalSheet = workbookData.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(originalSheet, { header: 1, defval: '', raw: false });
                const newSheet = XLSX.utils.aoa_to_sheet(jsonData);
                
                // å¦‚æœæ˜¯"æ€ªç‰©ç»„"sheeté¡µï¼Œæ›´æ–°"æ•Œäººç»„ID"åˆ—ã€"å”¯ä¸€ID"åˆ—ã€"ç« èŠ‚"åˆ—ã€"å…³å¡ç±»å‹"åˆ—ã€"ä¸»é¢˜"åˆ—å’Œ"å°å…³åºå·"åˆ—çš„æ•°æ®
                if (sheetName === monsterGroupSheetName) {
                    // ä»ç¬¬äºŒè¡Œå¼€å§‹ï¼ˆç´¢å¼•1ï¼‰å¡«å……æ•°æ®
                    for (let i = 0; i < generatedData.length; i++) {
                        const rowIndex = i + 1; // ç¬¬äºŒè¡Œå¼€å§‹ï¼ˆç´¢å¼•1ï¼‰
                        
                        // å¡«å……æ•Œäººç»„ID
                        const enemyGroupCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: enemyGroupIdColIndex });
                        newSheet[enemyGroupCellAddress] = { v: generatedData[i].enemyGroupId, t: 'n' };
                        
                        // å¡«å……å”¯ä¸€ID
                        const uniqueIdCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: uniqueIdColIndex });
                        newSheet[uniqueIdCellAddress] = { v: generatedData[i].uniqueId, t: 'n' };
                        
                        // å¡«å……ç« èŠ‚IDï¼ˆå¦‚æœæ‰¾åˆ°äº†ç« èŠ‚åˆ—ï¼‰
                        if (chapterColInMonsterGroup >= 0) {
                            const chapterCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: chapterColInMonsterGroup });
                            newSheet[chapterCellAddress] = { v: generatedData[i].chapterId, t: 'n' };
                        }
                        
                        // å¡«å……å…³å¡ç±»å‹ï¼ˆå¦‚æœæ‰¾åˆ°äº†å…³å¡ç±»å‹åˆ—ï¼‰
                        if (stageTypeColInMonsterGroup >= 0) {
                            const stageTypeCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: stageTypeColInMonsterGroup });
                            const stageTypeValue = generatedData[i].stageType || '';
                            // åˆ¤æ–­å…³å¡ç±»å‹æ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ä¸²
                            const numStageType = Number(stageTypeValue);
                            newSheet[stageTypeCellAddress] = { 
                                v: stageTypeValue, 
                                t: (stageTypeValue !== '' && !isNaN(numStageType)) ? 'n' : 's' 
                            };
                        }
                        
                        // å¡«å……ä¸»é¢˜ï¼ˆå¦‚æœæ‰¾åˆ°äº†ä¸»é¢˜åˆ—ï¼‰
                        if (themeColInMonsterGroup >= 0) {
                            const themeCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: themeColInMonsterGroup });
                            const themeValue = generatedData[i].theme || '';
                            // åˆ¤æ–­ä¸»é¢˜æ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ä¸²
                            const numTheme = Number(themeValue);
                            newSheet[themeCellAddress] = { 
                                v: themeValue, 
                                t: (themeValue !== '' && !isNaN(numTheme)) ? 'n' : 's' 
                            };
                        }
                        
                        // å¡«å……å°å…³åºå·ï¼ˆå¦‚æœæ‰¾åˆ°äº†å°å…³åºå·åˆ—ï¼‰
                        if (stageSeqColInMonsterGroup >= 0) {
                            const stageSeqCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: stageSeqColInMonsterGroup });
                            const stageSeqValue = generatedData[i].stageSeq || '';
                            // åˆ¤æ–­å°å…³åºå·æ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ä¸²
                            const numStageSeq = Number(stageSeqValue);
                            newSheet[stageSeqCellAddress] = { 
                                v: stageSeqValue, 
                                t: (stageSeqValue !== '' && !isNaN(numStageSeq)) ? 'n' : 's' 
                            };
                        }
                        
                        // å¡«å……æ•ŒäººIDï¼ˆå¦‚æœæ‰¾åˆ°äº†æ•ŒäººIDåˆ—ï¼‰
                        if (enemyIdColInMonsterGroup >= 0) {
                            const enemyIdCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: enemyIdColInMonsterGroup });
                            const enemyIdValue = generatedData[i].enemyId || '';
                            // åˆ¤æ–­æ•ŒäººIDæ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ä¸²
                            const numEnemyId = Number(enemyIdValue);
                            newSheet[enemyIdCellAddress] = { 
                                v: enemyIdValue, 
                                t: (enemyIdValue !== '' && !isNaN(numEnemyId)) ? 'n' : 's' 
                            };
                        }
                        
                        // å¡«å……ç«™ä½ï¼ˆå¦‚æœæ‰¾åˆ°äº†ç«™ä½åˆ—ï¼‰
                        if (positionColInMonsterGroup >= 0) {
                            const positionCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: positionColInMonsterGroup });
                            const positionValue = generatedData[i].position || '';
                            // åˆ¤æ–­ç«™ä½æ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ä¸²
                            const numPosition = Number(positionValue);
                            newSheet[positionCellAddress] = { 
                                v: positionValue, 
                                t: (positionValue !== '' && !isNaN(numPosition)) ? 'n' : 's' 
                            };
                        }
                        
                        // å¡«å……æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´ï¼ˆå¦‚æœæ‰¾åˆ°äº†æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´åˆ—ï¼‰
                        if (hpTimesColInMonsterGroup >= 0) {
                            const hpTimesCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: hpTimesColInMonsterGroup });
                            const hpTimesValue = generatedData[i].hpTimes || '';
                            newSheet[hpTimesCellAddress] = { 
                                v: hpTimesValue, 
                                t: 's' // å€ç‡èŒƒå›´æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼ˆå¦‚"1*1"æˆ–"0.95*1.05"ï¼‰
                            };
                        }
                        
                        // å¡«å……æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´ï¼ˆå¦‚æœæ‰¾åˆ°äº†æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´åˆ—ï¼‰
                        if (atkTimesColInMonsterGroup >= 0) {
                            const atkTimesCellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: atkTimesColInMonsterGroup });
                            const atkTimesValue = generatedData[i].atkTimes || '';
                            newSheet[atkTimesCellAddress] = { 
                                v: atkTimesValue, 
                                t: 's' // å€ç‡èŒƒå›´æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼ˆå¦‚"1*1"æˆ–"0.95*1.05"ï¼‰
                            };
                        }
                    }
                    
                    // æ›´æ–°èŒƒå›´
                    const colsToCheck = [enemyGroupIdColIndex, uniqueIdColIndex];
                    if (chapterColInMonsterGroup >= 0) colsToCheck.push(chapterColInMonsterGroup);
                    if (stageTypeColInMonsterGroup >= 0) colsToCheck.push(stageTypeColInMonsterGroup);
                    if (themeColInMonsterGroup >= 0) colsToCheck.push(themeColInMonsterGroup);
                    if (stageSeqColInMonsterGroup >= 0) colsToCheck.push(stageSeqColInMonsterGroup);
                    if (enemyIdColInMonsterGroup >= 0) colsToCheck.push(enemyIdColInMonsterGroup);
                    if (positionColInMonsterGroup >= 0) colsToCheck.push(positionColInMonsterGroup);
                    if (hpTimesColInMonsterGroup >= 0) colsToCheck.push(hpTimesColInMonsterGroup);
                    if (atkTimesColInMonsterGroup >= 0) colsToCheck.push(atkTimesColInMonsterGroup);
                    const maxCol = Math.max(...jsonData.map(row => row.length), ...colsToCheck);
                    const maxRow = Math.max(jsonData.length - 1, 1 + generatedData.length - 1);
                    newSheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: maxRow, c: maxCol } });
                }
                
                XLSX.utils.book_append_sheet(processedWorkbook, newSheet, sheetName);
            });

            // æ˜¾ç¤ºå¤„ç†ç»“æœ
            const resultDiv = document.getElementById('processResult');
            const uniqueIdCount = generatedData.length;
            const chapterIdCount = chapterColInMonsterGroup >= 0 ? generatedData.length : 0;
            const stageTypeCount = stageTypeColInMonsterGroup >= 0 ? generatedData.length : 0;
            const themeCount = themeColInMonsterGroup >= 0 ? generatedData.length : 0;
            const enemyIdCount = enemyIdColInMonsterGroup >= 0 ? generatedData.length : 0;
            let resultText = `<strong>å¤„ç†å®Œæˆï¼</strong><br>å·²ç”Ÿæˆ ${generatedData.length} ä¸ª"æ•Œäººç»„ID"æ•°æ®<br>å·²ç”Ÿæˆ ${uniqueIdCount} ä¸ª"å”¯ä¸€ID"æ•°æ®`;
            if (chapterIdCount > 0) {
                resultText += `<br>å·²ç”Ÿæˆ ${chapterIdCount} ä¸ª"ç« èŠ‚ID"æ•°æ®`;
            }
            if (stageTypeCount > 0) {
                resultText += `<br>å·²ç”Ÿæˆ ${stageTypeCount} ä¸ª"å…³å¡ç±»å‹"æ•°æ®`;
            }
            if (themeCount > 0) {
                resultText += `<br>å·²ç”Ÿæˆ ${themeCount} ä¸ª"ä¸»é¢˜"æ•°æ®`;
            }
            if (enemyIdCount > 0) {
                resultText += `<br>å·²ç”Ÿæˆ ${enemyIdCount} ä¸ª"æ•ŒäººID"æ•°æ®`;
            }
            if (positionColInMonsterGroup >= 0) {
                const positionCount = generatedData.filter(d => d.position && d.position !== '').length;
                const positionEmptyCount = generatedData.filter(d => !d.position || d.position === '').length;
                resultText += `<br>å·²ç”Ÿæˆ ${positionCount} ä¸ª"ç«™ä½"æ•°æ®`;
                if (positionEmptyCount > 0) {
                    resultText += `<br><span style="color: #dc3545;">âš ï¸ æœ‰ ${positionEmptyCount} ä¸ª"ç«™ä½"æ•°æ®ä¸ºç©º</span>`;
                    resultText += `<br><span style="color: #6c757d; font-size: 0.9em;">è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°ï¼ˆæŒ‰F12ï¼‰æŸ¥çœ‹è¯¦ç»†åŸå› </span>`;
                }
            } else {
                resultText += `<br><span style="color: #ffc107;">âš ï¸ æœªæ‰¾åˆ°"ç«™ä½"åˆ—ï¼Œæ— æ³•å¡«å……ç«™ä½æ•°æ®</span>`;
            }
            resultDiv.innerHTML = resultText;
            resultDiv.style.display = 'block';

            // ä¿å­˜ç”Ÿæˆçš„æ•°æ®ä¾›å¯¼å‡ºä½¿ç”¨
            globalGeneratedData = generatedData;

            // æ˜¾ç¤ºå¤„ç†åçš„æ•°æ®é¢„è§ˆ
            displayProcessedData(processedWorkbook);
        }

        // æ˜¾ç¤ºå¤„ç†åçš„æ•°æ®
        function displayProcessedData(wb) {
            const displayDiv = document.getElementById('processedDataDisplay');
            displayDiv.style.display = 'block';

            // åˆ›å»ºsheetæ ‡ç­¾
            const sheetTabsDiv = document.getElementById('processedSheetTabs');
            sheetTabsDiv.innerHTML = '';
            wb.SheetNames.forEach((name, index) => {
                const tab = document.createElement('div');
                tab.className = 'sheet-tab' + (index === 0 ? ' active' : '');
                tab.textContent = name;
                tab.onclick = () => {
                    document.querySelectorAll('#processedSheetTabs .sheet-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    displayProcessedSheet(wb.Sheets[name], name);
                };
                sheetTabsDiv.appendChild(tab);
            });

            // æ˜¾ç¤ºç¬¬ä¸€ä¸ªsheet
            if (wb.SheetNames.length > 0) {
                displayProcessedSheet(wb.Sheets[wb.SheetNames[0]], wb.SheetNames[0]);
            }
        }

        // æ˜¾ç¤ºå¤„ç†åçš„sheetæ•°æ®
        function displayProcessedSheet(sheet, sheetName) {
            const container = document.getElementById('processedTableContainer');
            const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
            
            let html = '<div class="table-wrapper"><table class="excel-table"><thead><tr>';
            html += '<th class="row-header">è¡Œ/åˆ—</th>';
            for (let C = range.s.c; C <= range.e.c; C++) {
                const colName = getExcelColumnName(C);
                html += `<th>${colName}</th>`;
            }
            html += '</tr></thead><tbody>';

            for (let R = range.s.r; R <= range.e.r; R++) {
                html += '<tr>';
                html += `<td class="row-header">${R + 1}</td>`;
                for (let C = range.s.c; C <= range.e.c; C++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                    const cell = sheet[cellAddress];
                    const cellValue = cell ? (cell.w || cell.v || '') : '';
                    const displayValue = cellValue === '' ? '&nbsp;' : escapeHtml(String(cellValue));
                    html += `<td>${displayValue}</td>`;
                }
                html += '</tr>';
            }

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // åˆ›å»ºstage_id sheeté¡µ
        function createStageSheet(chapterId, stageData) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            // è®¾ç½®å‰5è¡Œçš„å›ºå®šå€¼
            const headerData = [
                ['##var', '##var', '##var', '##var', '##var', '##var', '##var'], // ç¬¬1è¡Œ
                ['##var', 'id', 'chapter', 'stage', 'stageType', 'bossAnim', 'stageExp'], // ç¬¬2è¡Œ
                ['##type', 'int', 'int', 'int', 'int', '(array#sep=*),float', 'int'], // ç¬¬3è¡Œ
                ['##group', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s'], // ç¬¬4è¡Œ
                ['##', 'å±‚ID', 'ç« èŠ‚ID', 'å±‚ID', 'å±‚ç±»å‹', 'BOSSè™šå½±', 'è¿‡å…³ç»éªŒå€¼'] // ç¬¬5è¡Œ
            ];
            
            // å†™å…¥è¡¨å¤´ï¼ˆå‰5è¡Œï¼‰
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 7; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = headerData[row][col] || '';
                    sheet[cellAddress] = { v: value, t: 's' };
                }
            }
            
            // ä»stageDataå¡«å……æ•°æ®ï¼ˆä»ç¬¬6è¡Œå¼€å§‹ï¼Œç´¢å¼•5ï¼‰
            if (stageData && stageData.length > 0) {
                stageData.forEach((item, index) => {
                    const row = 5 + index; // ä»ç¬¬6è¡Œå¼€å§‹ï¼ˆç´¢å¼•5ï¼‰
                    
                    // Båˆ—ï¼ˆç´¢å¼•1ï¼‰å¡«å…¥idï¼ˆå±‚IDï¼Œå¯¹åº”å°å…³åºå·ï¼‰
                    const cellAddressB = XLSX.utils.encode_cell({ r: row, c: 1 });
                    sheet[cellAddressB] = { v: item.id || '', t: typeof item.id === 'number' ? 'n' : 's' };
                    
                    // Cåˆ—ï¼ˆç´¢å¼•2ï¼‰å¡«å…¥ç« èŠ‚ID
                    const cellAddressC = XLSX.utils.encode_cell({ r: row, c: 2 });
                    sheet[cellAddressC] = { v: item.chapterId || chapterId, t: 'n' };
                    
                    // Dåˆ—ï¼ˆç´¢å¼•3ï¼‰å¡«å…¥stageï¼ˆå±‚IDï¼Œå¯¹åº”å°å…³åºå·ï¼‰
                    const cellAddressD = XLSX.utils.encode_cell({ r: row, c: 3 });
                    sheet[cellAddressD] = { v: item.stage || item.id || '', t: typeof item.stage === 'number' ? 'n' : (typeof item.id === 'number' ? 'n' : 's') };
                    
                    // Eåˆ—ï¼ˆç´¢å¼•4ï¼‰å¡«å…¥stageTypeï¼ˆå±‚ç±»å‹ï¼‰
                    const cellAddressE = XLSX.utils.encode_cell({ r: row, c: 4 });
                    sheet[cellAddressE] = { v: item.stageType || '', t: typeof item.stageType === 'number' ? 'n' : 's' };
                    
                    // Fåˆ—ï¼ˆç´¢å¼•5ï¼‰å¡«å…¥bossAnimï¼ˆBOSSè™šå½±ï¼‰
                    const cellAddressF = XLSX.utils.encode_cell({ r: row, c: 5 });
                    sheet[cellAddressF] = { v: item.bossAnim || '', t: 's' };
                    
                    // Gåˆ—ï¼ˆç´¢å¼•6ï¼‰å¡«å…¥stageExpï¼ˆè¿‡å…³ç»éªŒå€¼ï¼‰
                    const cellAddressG = XLSX.utils.encode_cell({ r: row, c: 6 });
                    sheet[cellAddressG] = { v: item.stageExp || '', t: typeof item.stageExp === 'number' ? 'n' : 's' };
                });
            }
            
            // è®¾ç½®èŒƒå›´
            const maxRow = Math.max(4, 5 + (stageData ? stageData.length - 1 : 0));
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: maxRow, c: 6 } });
            
            return sheet;
        }

        // åˆ›å»ºstageEvent_id sheeté¡µ
        function createStageEventSheet(chapterId, eventData) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            // è®¾ç½®å‰5è¡Œçš„å›ºå®šå€¼
            const headerData = [
                ['##var', '##var', '##var', '##var'], // ç¬¬1è¡Œ
                ['##var', 'id', 'eventId', 'eventFirst'], // ç¬¬2è¡Œ
                ['##type', 'int', '(array#sep=|),(array#sep=*),int', 'int'], // ç¬¬3è¡Œ
                ['##group', 'c,s', 'c,s', 'c,s'], // ç¬¬4è¡Œ
                ['##', 'å±‚ID', 'äº‹ä»¶éšæœº', 'é¦–æ¬¡äº‹ä»¶'] // ç¬¬5è¡Œ
            ];
            
            // å†™å…¥è¡¨å¤´ï¼ˆå‰5è¡Œï¼‰
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = headerData[row][col] || '';
                    sheet[cellAddress] = { v: value, t: 's' };
                }
            }
            
            // ä»eventDataå¡«å……æ•°æ®ï¼ˆä»ç¬¬6è¡Œå¼€å§‹ï¼Œç´¢å¼•5ï¼‰
            if (eventData && eventData.length > 0) {
                eventData.forEach((item, index) => {
                    const row = 5 + index;
                    
                    // Båˆ—ï¼ˆç´¢å¼•1ï¼‰å¡«å…¥idï¼ˆå±‚IDï¼Œå¯¹åº”å°å…³åºå·ï¼‰
                    const cellAddressB = XLSX.utils.encode_cell({ r: row, c: 1 });
                    sheet[cellAddressB] = { v: item.id || '', t: typeof item.id === 'number' ? 'n' : 's' };
                    
                    // Cåˆ—ï¼ˆç´¢å¼•2ï¼‰å¡«å…¥eventIdï¼ˆäº‹ä»¶éšæœºï¼‰
                    const cellAddressC = XLSX.utils.encode_cell({ r: row, c: 2 });
                    sheet[cellAddressC] = { v: item.eventId || '', t: 's' };
                    
                    // Dåˆ—ï¼ˆç´¢å¼•3ï¼‰å¡«å…¥eventFirstï¼ˆé¦–æ¬¡äº‹ä»¶ï¼‰
                    const cellAddressD = XLSX.utils.encode_cell({ r: row, c: 3 });
                    sheet[cellAddressD] = { v: item.eventFirst || '', t: typeof item.eventFirst === 'number' ? 'n' : 's' };
                });
            }
            
            // è®¾ç½®èŒƒå›´
            const maxRow = Math.max(4, 5 + (eventData ? eventData.length - 1 : 0));
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: maxRow, c: 3 } });
            
            return sheet;
        }

        // åˆ›å»ºstageBattle_id sheeté¡µ
        function createStageBattleSheet(chapterId, battleData) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            // è®¾ç½®å‰5è¡Œçš„å›ºå®šå€¼
            const headerData = [
                ['##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var'], // ç¬¬1è¡Œ
                ['##var', 'id', 'hp', 'atk', 'firstHp', 'firstAtk', 'group', 'rogue', 'point', 'roll', 'diceHand', 'prop', 'enemyExp', 'stageExp'], // ç¬¬2è¡Œ
                ['##type', 'int', 'int', 'int', 'int', 'int', '(array#sep=*),int', '(array#sep=*),int', '(array#sep=|),(array#sep=*),int', '(array#sep=|),(array#sep=*),int', '(array#sep=*),int', '(array#sep=|),(array#sep=*),int', 'int', 'int'], // ç¬¬3è¡Œ
                ['##group', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s'], // ç¬¬4è¡Œ
                ['##', 'å±‚ID', 'æ ‡å‡†è¡€é‡', 'æ ‡å‡†æ”»å‡»åŠ›', 'ç¬¬ä¸€æ¬¡è¡€é‡', 'ç¬¬ä¸€æ¬¡æ”»å‡»åŠ›', 'éšæœºæ•Œäººç»„', 'ç»“æŸæ˜¯å¦æœ‰rogue', 'ç¬¬ä¸€æ¬¡åˆ°è¾¾å¿…å‡ºç‚¹æ•°', 'ç¬¬å‡ æ¬¡é‡ç½®å‡ºæŸä¸ªç‚¹æ•°', 'ç‰Œå‹æ¦‚ç‡', 'é“å…·æ‰è½', 'å•æ€ªæ‰è½ç»éªŒå€¼', 'è¿‡å…³ç»éªŒå€¼'] // ç¬¬5è¡Œ
            ];
            
            // å†™å…¥è¡¨å¤´ï¼ˆå‰5è¡Œï¼‰
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 14; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = headerData[row][col] || '';
                    sheet[cellAddress] = { v: value, t: 's' };
                }
            }
            
            // ä»battleDataå¡«å……æ•°æ®ï¼ˆä»ç¬¬6è¡Œå¼€å§‹ï¼Œç´¢å¼•5ï¼‰
            if (battleData && battleData.length > 0) {
                battleData.forEach((item, index) => {
                    const row = 5 + index;
                    
                    // Båˆ—ï¼ˆç´¢å¼•1ï¼‰å¡«å…¥idï¼ˆå±‚IDï¼‰
                    const cellAddressB = XLSX.utils.encode_cell({ r: row, c: 1 });
                    sheet[cellAddressB] = { v: item.id || '', t: typeof item.id === 'number' ? 'n' : 's' };
                    
                    // Cåˆ—ï¼ˆç´¢å¼•2ï¼‰å¡«å…¥hpï¼ˆæ ‡å‡†è¡€é‡ï¼‰
                    const cellAddressC = XLSX.utils.encode_cell({ r: row, c: 2 });
                    sheet[cellAddressC] = { v: item.hp || '', t: typeof item.hp === 'number' ? 'n' : 's' };
                    
                    // Dåˆ—ï¼ˆç´¢å¼•3ï¼‰å¡«å…¥atkï¼ˆæ ‡å‡†æ”»å‡»åŠ›ï¼‰
                    const cellAddressD = XLSX.utils.encode_cell({ r: row, c: 3 });
                    sheet[cellAddressD] = { v: item.atk || '', t: typeof item.atk === 'number' ? 'n' : 's' };
                    
                    // Eåˆ—ï¼ˆç´¢å¼•4ï¼‰å¡«å…¥firstHpï¼ˆç¬¬ä¸€æ¬¡è¡€é‡ï¼‰
                    const cellAddressE = XLSX.utils.encode_cell({ r: row, c: 4 });
                    sheet[cellAddressE] = { v: item.firstHp || '', t: typeof item.firstHp === 'number' ? 'n' : 's' };
                    
                    // Fåˆ—ï¼ˆç´¢å¼•5ï¼‰å¡«å…¥firstAtkï¼ˆç¬¬ä¸€æ¬¡æ”»å‡»åŠ›ï¼‰
                    const cellAddressF = XLSX.utils.encode_cell({ r: row, c: 5 });
                    sheet[cellAddressF] = { v: item.firstAtk || '', t: typeof item.firstAtk === 'number' ? 'n' : 's' };
                    
                    // Gåˆ—ï¼ˆç´¢å¼•6ï¼‰å¡«å…¥groupï¼ˆéšæœºæ•Œäººç»„ï¼Œå°å…³åºå·*100+1ï¼‰
                    const cellAddressG = XLSX.utils.encode_cell({ r: row, c: 6 });
                    const groupValue = item.group !== '' && item.group !== null && item.group !== undefined ? item.group : '';
                    sheet[cellAddressG] = { v: groupValue, t: typeof groupValue === 'number' ? 'n' : 's' };
                    
                    // Håˆ—ï¼ˆç´¢å¼•7ï¼‰å¡«å…¥rogueï¼ˆç»“æŸæ˜¯å¦æœ‰rogueï¼‰
                    const cellAddressH = XLSX.utils.encode_cell({ r: row, c: 7 });
                    sheet[cellAddressH] = { v: item.rogue || '', t: 's' };
                    
                    // Iåˆ—ï¼ˆç´¢å¼•8ï¼‰å¡«å…¥pointï¼ˆç¬¬ä¸€æ¬¡åˆ°è¾¾å¿…å‡ºç‚¹æ•°ï¼‰
                    const cellAddressI = XLSX.utils.encode_cell({ r: row, c: 8 });
                    sheet[cellAddressI] = { v: item.point || '', t: 's' };
                    
                    // Jåˆ—ï¼ˆç´¢å¼•9ï¼‰å¡«å…¥rollï¼ˆç¬¬å‡ æ¬¡é‡ç½®å‡ºæŸä¸ªç‚¹æ•°ï¼‰
                    const cellAddressJ = XLSX.utils.encode_cell({ r: row, c: 9 });
                    sheet[cellAddressJ] = { v: item.roll || '', t: 's' };
                    
                    // Kåˆ—ï¼ˆç´¢å¼•10ï¼‰å¡«å…¥diceHandï¼ˆç‰Œå‹æ¦‚ç‡ï¼Œå¦‚æœæœ‰å€¼ï¼‰
                    const cellAddressK = XLSX.utils.encode_cell({ r: row, c: 10 });
                    const diceHandValue = item.diceHand !== '' && item.diceHand !== null && item.diceHand !== undefined ? item.diceHand : '';
                    sheet[cellAddressK] = { v: diceHandValue, t: 's' };
                    
                    // Låˆ—ï¼ˆç´¢å¼•11ï¼‰å¡«å…¥propï¼ˆé“å…·æ‰è½ï¼Œå¦‚æœæœ‰å€¼ï¼‰
                    const cellAddressL = XLSX.utils.encode_cell({ r: row, c: 11 });
                    const propValue = item.prop !== '' && item.prop !== null && item.prop !== undefined ? item.prop : '';
                    sheet[cellAddressL] = { v: propValue, t: 's' };
                    
                    // Måˆ—ï¼ˆç´¢å¼•12ï¼‰å¡«å…¥enemyExpï¼ˆå•æ€ªæ‰è½ç»éªŒå€¼ï¼Œå¦‚æœæœ‰å€¼ï¼‰
                    const cellAddressM = XLSX.utils.encode_cell({ r: row, c: 12 });
                    const enemyExpValue = item.enemyExp !== '' && item.enemyExp !== null && item.enemyExp !== undefined ? item.enemyExp : '';
                    sheet[cellAddressM] = { v: enemyExpValue, t: typeof enemyExpValue === 'number' ? 'n' : 's' };
                    
                    // Nåˆ—ï¼ˆç´¢å¼•13ï¼‰å¡«å…¥stageExpï¼ˆè¿‡å…³ç»éªŒå€¼ï¼‰
                    const cellAddressN = XLSX.utils.encode_cell({ r: row, c: 13 });
                    sheet[cellAddressN] = { v: item.stageExp || '', t: typeof item.stageExp === 'number' ? 'n' : 's' };
                });
            }
            
            // è®¾ç½®èŒƒå›´
            const maxRow = Math.max(4, 5 + (battleData ? battleData.length - 1 : 0));
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: maxRow, c: 13 } });
            
            return sheet;
        }

        // åˆ›å»ºgroup_id sheeté¡µ
        function createGroupSheet(chapterId, groupData) {
            const sheet = XLSX.utils.aoa_to_sheet([]);
            
            // è®¾ç½®å‰5è¡Œçš„å›ºå®šå€¼
            const headerData = [
                ['##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var', '##var'], // ç¬¬1è¡Œ
                ['##var', 'id', 'groupId', 'enemy', 'position', 'start', 'passiveSkill', 'hpTimes', 'atkTimes', 'skillOrder'], // ç¬¬2è¡Œ
                ['##type', 'int', 'int', 'temp.EEnemy', 'int', '(array#sep=*),int', '(array#sep=*),int', '(array#sep=*),float', '(array#sep=*),float', '(array#sep=*),temp.EEnemyBehavior'], // ç¬¬3è¡Œ
                ['##group', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s', 'c,s'], // ç¬¬4è¡Œ
                ['##', 'å”¯ä¸€ID', 'æ•Œäººç»„ID', 'æ•ŒäººID', 'ç«™ä½', 'æ€ªç‰©åˆå§‹çŠ¶æ€', 'å¸¸é©»è¢«åŠ¨æŠ€èƒ½', 'æ ‡å‡†è¡€é‡å€ç‡èŒƒå›´', 'æ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´', 'æŠ€èƒ½é¡ºåº'] // ç¬¬5è¡Œ
            ];
            
            // å†™å…¥è¡¨å¤´ï¼ˆå‰5è¡Œï¼‰
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 10; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = headerData[row][col] || '';
                    sheet[cellAddress] = { v: value, t: 's' };
                }
            }
            
            // ä»groupDataå¡«å……æ•°æ®ï¼ˆä»ç¬¬6è¡Œå¼€å§‹ï¼Œç´¢å¼•5ï¼‰
            if (groupData && groupData.length > 0) {
                groupData.forEach((item, index) => {
                    const row = 5 + index;
                    
                    // Båˆ—ï¼ˆç´¢å¼•1ï¼‰å¡«å…¥idï¼ˆå”¯ä¸€IDï¼‰
                    const cellAddressB = XLSX.utils.encode_cell({ r: row, c: 1 });
                    sheet[cellAddressB] = { v: item.uniqueId || '', t: typeof item.uniqueId === 'number' ? 'n' : 's' };
                    
                    // Cåˆ—ï¼ˆç´¢å¼•2ï¼‰å¡«å…¥groupIdï¼ˆæ•Œäººç»„IDï¼‰
                    const cellAddressC = XLSX.utils.encode_cell({ r: row, c: 2 });
                    sheet[cellAddressC] = { v: item.enemyGroupId || '', t: typeof item.enemyGroupId === 'number' ? 'n' : 's' };
                    
                    // Dåˆ—ï¼ˆç´¢å¼•3ï¼‰å¡«å…¥enemyï¼ˆæ•ŒäººIDï¼‰
                    const cellAddressD = XLSX.utils.encode_cell({ r: row, c: 3 });
                    sheet[cellAddressD] = { v: item.enemyId || '', t: 's' };
                    
                    // Eåˆ—ï¼ˆç´¢å¼•4ï¼‰å¡«å…¥positionï¼ˆç«™ä½ï¼‰
                    const cellAddressE = XLSX.utils.encode_cell({ r: row, c: 4 });
                    sheet[cellAddressE] = { v: item.position || '', t: typeof item.position === 'number' ? 'n' : 's' };
                    
                    // Fåˆ—ï¼ˆç´¢å¼•5ï¼‰å¡«å…¥startï¼ˆæ€ªç‰©åˆå§‹çŠ¶æ€ï¼‰
                    const cellAddressF = XLSX.utils.encode_cell({ r: row, c: 5 });
                    sheet[cellAddressF] = { v: item.start || '', t: 's' };
                    
                    // Gåˆ—ï¼ˆç´¢å¼•6ï¼‰å¡«å…¥passiveSkillï¼ˆå¸¸é©»è¢«åŠ¨æŠ€èƒ½ï¼‰
                    const cellAddressG = XLSX.utils.encode_cell({ r: row, c: 6 });
                    sheet[cellAddressG] = { v: item.passiveSkill || '', t: 's' };
                    
                    // Håˆ—ï¼ˆç´¢å¼•7ï¼‰å¡«å…¥hpTimesï¼ˆæ ‡å‡†è¡€é‡å€ç‡èŒƒå›´ï¼‰
                    const cellAddressH = XLSX.utils.encode_cell({ r: row, c: 7 });
                    sheet[cellAddressH] = { v: item.hpTimes || '', t: 's' };
                    
                    // Iåˆ—ï¼ˆç´¢å¼•8ï¼‰å¡«å…¥atkTimesï¼ˆæ ‡å‡†æ”»å‡»åŠ›å€ç‡èŒƒå›´ï¼‰
                    const cellAddressI = XLSX.utils.encode_cell({ r: row, c: 8 });
                    sheet[cellAddressI] = { v: item.atkTimes || '', t: 's' };
                    
                    // Jåˆ—ï¼ˆç´¢å¼•9ï¼‰å¡«å…¥skillOrderï¼ˆæŠ€èƒ½é¡ºåºï¼‰
                    const cellAddressJ = XLSX.utils.encode_cell({ r: row, c: 9 });
                    sheet[cellAddressJ] = { v: item.skillOrder || '', t: 's' };
                });
            }
            
            // è®¾ç½®èŒƒå›´
            const maxRow = Math.max(4, 5 + (groupData ? groupData.length - 1 : 0));
            sheet['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: maxRow, c: 9 } });
            
            return sheet;
        }

        // ç¬¬ä¸‰éƒ¨åˆ†ï¼šæŒ‰ç« èŠ‚å¯¼å‡ºæ–‡ä»¶
        function exportFiles() {
            if (!globalGeneratedData || !globalPlanData || !workbookData) {
                alert('è¯·å…ˆå¤„ç†æ•°æ®ï¼ˆæ­¥éª¤2ï¼‰');
                return;
            }

            // è·å–å¯¼å‡ºé€‰é¡¹
            const exportOption = document.querySelector('input[name="exportOption"]:checked');
            const exportType = exportOption ? exportOption.value : 'all';
            
            // è·å–"å…³å¡è§„åˆ’æ€»"æ•°æ®
            const planData = globalPlanData.data;
            const headerRow = globalPlanData.headerRow;
            
            // æŸ¥æ‰¾åˆ—ç´¢å¼•
            let chapterColIndex = -1;
            let stageSeqColIndex = -1;
            let stageTypeColIndex = -1;
            let bossEliteColIndex = -1;
            let randomEventColIndex = -1;
            let firstRandomEventColIndex = -1;
            let standardHpColIndex = -1;
            let standardAtkColIndex = -1;
            let diceHandColIndex = -1;
            let propColIndex = -1;
            let enemyExpColIndex = -1;
            
            // å…ˆè¾“å‡ºæ‰€æœ‰åˆ—åç”¨äºè°ƒè¯•
            console.log('å…³å¡è§„åˆ’æ€»çš„æ‰€æœ‰åˆ—å:', headerRow.map((h, idx) => `${idx}: ${h}`));
            
            for (let i = 0; i < headerRow.length; i++) {
                const header = String(headerRow[i]).trim();
                if (header.includes('ç« èŠ‚') || header === 'ç« èŠ‚') {
                    chapterColIndex = i;
                }
                if (header.includes('å°å…³åºå·') || header === 'å°å…³åºå·' || (header.includes('åºå·') && !header.includes('å”¯ä¸€'))) {
                    stageSeqColIndex = i;
                }
                if (header.includes('å…³å¡ç±»å‹') || header === 'å…³å¡ç±»å‹' || header.includes('ç±»å‹')) {
                    stageTypeColIndex = i;
                }
                if (header.includes('bosså’Œç²¾è‹±') || header === 'bosså’Œç²¾è‹±' || (header.includes('boss') && header.includes('ç²¾è‹±'))) {
                    bossEliteColIndex = i;
                }
                // æŸ¥æ‰¾"éšæœºäº‹ä»¶(è§„åˆ’)"åˆ—ï¼Œæ”¯æŒå¤šç§å¯èƒ½çš„åˆ—å
                // ä¼˜å…ˆç²¾ç¡®åŒ¹é…ï¼Œç„¶åæ¨¡ç³ŠåŒ¹é…
                if (header === 'éšæœºäº‹ä»¶(è§„åˆ’)' || 
                    header === 'éšæœºäº‹ä»¶ï¼ˆè§„åˆ’ï¼‰' ||  // æ”¯æŒä¸­æ–‡æ‹¬å·
                    header.includes('éšæœºäº‹ä»¶(è§„åˆ’)') || 
                    header.includes('éšæœºäº‹ä»¶ï¼ˆè§„åˆ’ï¼‰') ||
                    (header.includes('éšæœºäº‹ä»¶') && header.includes('è§„åˆ’'))) {
                    randomEventColIndex = i;
                    console.log('æ‰¾åˆ°"éšæœºäº‹ä»¶(è§„åˆ’)"åˆ—ï¼Œç´¢å¼•:', i, 'åˆ—å:', header);
                } else if (randomEventColIndex === -1 && header === 'éšæœºäº‹ä»¶') {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°"éšæœºäº‹ä»¶(è§„åˆ’)"ï¼Œåˆ™ä½¿ç”¨"éšæœºäº‹ä»¶"åˆ—
                    randomEventColIndex = i;
                    console.log('æ‰¾åˆ°"éšæœºäº‹ä»¶"åˆ—ï¼ˆä½œä¸ºéšæœºäº‹ä»¶(è§„åˆ’)ä½¿ç”¨ï¼‰ï¼Œç´¢å¼•:', i, 'åˆ—å:', header);
                }
                if (header.includes('é¦–æ¬¡éšæœºäº‹ä»¶') || header === 'é¦–æ¬¡éšæœºäº‹ä»¶') {
                    firstRandomEventColIndex = i;
                }
                if (header.includes('æ ‡å‡†è¡€é‡') || header === 'æ ‡å‡†è¡€é‡') {
                    standardHpColIndex = i;
                }
                if (header.includes('æ ‡å‡†æ”»å‡»') || header === 'æ ‡å‡†æ”»å‡»') {
                    standardAtkColIndex = i;
                }
                if (header.includes('ç‰Œå‹æ¦‚ç‡') || header === 'ç‰Œå‹æ¦‚ç‡') {
                    diceHandColIndex = i;
                }
                if (header.includes('é“å…·æ‰è½') || header === 'é“å…·æ‰è½') {
                    propColIndex = i;
                }
                if (header.includes('å•æ€ªæ‰è½ç»éªŒå€¼') || header === 'å•æ€ªæ‰è½ç»éªŒå€¼') {
                    enemyExpColIndex = i;
                }
            }
            
            // è¾“å‡ºåˆ—ç´¢å¼•æŸ¥æ‰¾ç»“æœ
            console.log('åˆ—ç´¢å¼•æŸ¥æ‰¾ç»“æœ:', {
                chapterColIndex: chapterColIndex,
                stageSeqColIndex: stageSeqColIndex,
                stageTypeColIndex: stageTypeColIndex,
                bossEliteColIndex: bossEliteColIndex,
                randomEventColIndex: randomEventColIndex,
                firstRandomEventColIndex: firstRandomEventColIndex
            });
            
            if (chapterColIndex === -1 || stageSeqColIndex === -1) {
                alert('æœªæ‰¾åˆ°å¿…è¦çš„åˆ—ï¼šç« èŠ‚ã€å°å…³åºå·');
                return;
            }
            
            // è¯»å–"æ€ªç‰©åˆ†å¸ƒ"sheeté¡µ
            let monsterDistributionSheet = null;
            let monsterDistributionData = null;
            let monsterIdColIndex = -1;
            let specialScaleColIndex = -1;
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('æ€ªç‰©åˆ†å¸ƒ')) {
                    monsterDistributionSheet = workbookData.Sheets[sheetName];
                    monsterDistributionData = XLSX.utils.sheet_to_json(monsterDistributionSheet, { header: 1, defval: '' });
                    if (monsterDistributionData.length > 0) {
                        const distHeaderRow = monsterDistributionData[0];
                        for (let i = 0; i < distHeaderRow.length; i++) {
                            const header = String(distHeaderRow[i]).trim();
                            if (header.includes('æ€ªç‰©id') || header === 'æ€ªç‰©id' || header.includes('æ€ªç‰©ID')) {
                                monsterIdColIndex = i;
                            }
                            if (header.includes('ç‰¹æ®Šç¼©æ”¾') || header === 'ç‰¹æ®Šç¼©æ”¾') {
                                specialScaleColIndex = i;
                            }
                        }
                    }
                    break;
                }
            }
            
            // è¯»å–"éšæœºäº‹ä»¶"sheeté¡µ
            let randomEventSheet = null;
            let randomEventData = null;
            let eventDistributionColIndex = -1;
            let firstEventColIndex = -1;
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('éšæœºäº‹ä»¶')) {
                    randomEventSheet = workbookData.Sheets[sheetName];
                    randomEventData = XLSX.utils.sheet_to_json(randomEventSheet, { header: 1, defval: '' });
                    if (randomEventData.length > 0) {
                        const eventHeaderRow = randomEventData[0];
                        for (let i = 0; i < eventHeaderRow.length; i++) {
                            const header = String(eventHeaderRow[i]).trim();
                            if (header.includes('äº‹ä»¶åˆ†å¸ƒ') || header === 'äº‹ä»¶åˆ†å¸ƒ') {
                                eventDistributionColIndex = i;
                            }
                            if (header.includes('é¦–æ¬¡äº‹ä»¶') || header === 'é¦–æ¬¡äº‹ä»¶') {
                                firstEventColIndex = i;
                            }
                        }
                    }
                    break;
                }
            }
            
            // åˆ›å»ºæ€ªç‰©åˆ†å¸ƒæ˜ å°„ï¼ˆbosså’Œç²¾è‹± -> ç‰¹æ®Šç¼©æ”¾ï¼‰
            const bossEliteToSpecialScaleMap = new Map();
            if (monsterDistributionData && monsterIdColIndex >= 0 && specialScaleColIndex >= 0) {
                for (let row = 1; row < monsterDistributionData.length; row++) {
                    const monsterId = monsterDistributionData[row][monsterIdColIndex];
                    const specialScale = monsterDistributionData[row][specialScaleColIndex];
                    if (monsterId !== '' && monsterId !== null && monsterId !== undefined) {
                        // åŒæ—¶æ”¯æŒå­—ç¬¦ä¸²å’Œæ•°å­—æ ¼å¼çš„key
                        const key = String(monsterId).trim();
                        // åªæœ‰å½“specialScaleæœ‰å€¼æ—¶æ‰æ·»åŠ åˆ°æ˜ å°„ä¸­
                        if (specialScale !== '' && specialScale !== null && specialScale !== undefined) {
                            bossEliteToSpecialScaleMap.set(key, String(specialScale).trim());
                            // å¦‚æœæ˜¯æ•°å­—ï¼Œä¹Ÿæ·»åŠ æ•°å­—æ ¼å¼çš„key
                            const numKey = Number(monsterId);
                            if (!isNaN(numKey) && numKey.toString() !== key) {
                                bossEliteToSpecialScaleMap.set(String(numKey), String(specialScale).trim());
                            }
                        }
                    }
                }
                console.log('æ€ªç‰©åˆ†å¸ƒæ˜ å°„å·²åˆ›å»ºï¼Œå…±', bossEliteToSpecialScaleMap.size, 'æ¡è®°å½•');
                // è¾“å‡ºå‰å‡ æ¡è®°å½•ç”¨äºè°ƒè¯•
                if (bossEliteToSpecialScaleMap.size > 0) {
                    const entries = Array.from(bossEliteToSpecialScaleMap.entries()).slice(0, 5);
                    console.log('æ€ªç‰©åˆ†å¸ƒæ˜ å°„ç¤ºä¾‹ï¼ˆå‰5æ¡ï¼‰:', entries);
                }
            } else {
                console.log('æœªæ‰¾åˆ°æ€ªç‰©åˆ†å¸ƒsheeté¡µæˆ–åˆ—ç´¢å¼•æ— æ•ˆ', {
                    hasData: !!monsterDistributionData,
                    monsterIdColIndex: monsterIdColIndex,
                    specialScaleColIndex: specialScaleColIndex
                });
            }
            
            // åˆ›å»ºéšæœºäº‹ä»¶åˆ—è¡¨
            const randomEventList = [];
            if (randomEventData && eventDistributionColIndex >= 0 && firstEventColIndex >= 0) {
                for (let row = 1; row < randomEventData.length; row++) {
                    const eventDistribution = randomEventData[row][eventDistributionColIndex];
                    const firstEvent = randomEventData[row][firstEventColIndex];
                    if (eventDistribution !== '' && eventDistribution !== null && eventDistribution !== undefined) {
                        randomEventList.push({
                            eventDistribution: eventDistribution,
                            firstEvent: firstEvent
                        });
                    }
                }
            }

            // æå–å”¯ä¸€çš„ç« èŠ‚ID
            const chapterIds = new Set();
            for (let row = 1; row < planData.length; row++) {
                const val = planData[row][chapterColIndex];
                if (val !== '' && val !== null && val !== undefined) {
                    const numVal = Number(val);
                    if (!isNaN(numVal) && numVal > 0) {
                        chapterIds.add(numVal);
                    }
                }
            }

            let sortedChapterIds = Array.from(chapterIds).sort((a, b) => a - b);
            
            // å¦‚æœæ˜¯å•ä¸ªç« èŠ‚å¯¼å‡ºï¼Œç­›é€‰ç« èŠ‚ID
            if (exportType === 'single') {
                const singleChapterIdInput = document.getElementById('singleChapterId');
                const singleChapterId = singleChapterIdInput ? Number(singleChapterIdInput.value) : null;
                if (!singleChapterId || isNaN(singleChapterId) || singleChapterId <= 0) {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ç« èŠ‚ID');
                    return;
                }
                if (!chapterIds.has(singleChapterId)) {
                    alert(`ç« èŠ‚ID ${singleChapterId} ä¸å­˜åœ¨`);
                    return;
                }
                sortedChapterIds = [singleChapterId];
            }

            if (sortedChapterIds.length === 0) {
                alert('æœªæ‰¾åˆ°ç« èŠ‚ID');
                return;
            }

            // ä¸ºæ¯ä¸ªç« èŠ‚å¯¼å‡ºæ–‡ä»¶
            sortedChapterIds.forEach((chapterId, index) => {
                setTimeout(() => {
                    // ç­›é€‰è¯¥ç« èŠ‚çš„æ•°æ®
                    const chapterPlanData = [];
                    for (let row = 1; row < planData.length; row++) {
                        const val = planData[row][chapterColIndex];
                        const numVal = Number(val);
                        if (!isNaN(numVal) && numVal === chapterId) {
                            const bossElite = bossEliteColIndex >= 0 ? planData[row][bossEliteColIndex] : '';
                            let bossAnim = '';
                            if (bossElite && bossElite !== '' && bossElite !== null && bossElite !== undefined) {
                                const bossEliteStr = String(bossElite).trim();
                                // å°è¯•å¤šç§æ ¼å¼æŸ¥æ‰¾
                                bossAnim = bossEliteToSpecialScaleMap.get(bossEliteStr);
                                if (!bossAnim) {
                                    // å°è¯•æ•°å­—æ ¼å¼
                                    const numBossElite = Number(bossEliteStr);
                                    if (!isNaN(numBossElite)) {
                                        bossAnim = bossEliteToSpecialScaleMap.get(String(numBossElite));
                                    }
                                }
                                if (!bossAnim) {
                                    // å°è¯•åŸå§‹å€¼ï¼ˆä¸trimï¼‰
                                    bossAnim = bossEliteToSpecialScaleMap.get(String(bossElite));
                                }
                                
                                // è°ƒè¯•æ—¥å¿—ï¼šå½“å±‚IDä¸º20æ—¶è¾“å‡ºè¯¦ç»†ä¿¡æ¯
                                const stageSeq = planData[row][stageSeqColIndex];
                                if (Number(stageSeq) === 20) {
                                    console.log('å±‚IDä¸º20çš„BOSSè™šå½±æŸ¥æ‰¾:', {
                                        ç« èŠ‚ID: chapterId,
                                        å°å…³åºå·: stageSeq,
                                        bossEliteåŸå§‹å€¼: bossElite,
                                        bossEliteç±»å‹: typeof bossElite,
                                        bossEliteå­—ç¬¦ä¸²: bossEliteStr,
                                        bossEliteæ•°å­—: Number(bossEliteStr),
                                        æŸ¥æ‰¾ç»“æœ: bossAnim,
                                        æ˜ å°„ä¸­æ˜¯å¦æœ‰å­—ç¬¦ä¸²key: bossEliteToSpecialScaleMap.has(bossEliteStr),
                                        æ˜ å°„ä¸­æ˜¯å¦æœ‰æ•°å­—key: bossEliteToSpecialScaleMap.has(String(Number(bossEliteStr))),
                                        æ˜ å°„å¤§å°: bossEliteToSpecialScaleMap.size,
                                        æ˜ å°„ä¸­æ‰€æœ‰key: Array.from(bossEliteToSpecialScaleMap.keys()).slice(0, 10)
                                    });
                                }
                            }
                            
                            chapterPlanData.push({
                                rowIndex: row,
                                chapterId: chapterId,
                                stageSeq: planData[row][stageSeqColIndex],
                                stageType: stageTypeColIndex >= 0 ? planData[row][stageTypeColIndex] : '',
                                bossElite: bossElite,
                                bossAnim: bossAnim,
                                randomEvent: randomEventColIndex >= 0 ? planData[row][randomEventColIndex] : '',
                                firstRandomEvent: firstRandomEventColIndex >= 0 ? planData[row][firstRandomEventColIndex] : '',
                                standardHp: standardHpColIndex >= 0 ? planData[row][standardHpColIndex] : '',
                                standardAtk: standardAtkColIndex >= 0 ? planData[row][standardAtkColIndex] : '',
                                diceHand: diceHandColIndex >= 0 ? planData[row][diceHandColIndex] : '',
                                prop: propColIndex >= 0 ? planData[row][propColIndex] : '',
                                enemyExp: enemyExpColIndex >= 0 ? planData[row][enemyExpColIndex] : '',
                                rawRow: planData[row]
                            });
                        }
                    }
                    
                    // ç­›é€‰è¯¥ç« èŠ‚çš„æ€ªç‰©ç»„æ•°æ®
                    const chapterGroupData = globalGeneratedData.filter(item => item.chapterId === chapterId);
                    
                    // æ„å»ºstage_idæ•°æ®ï¼ˆé€è¡Œéå†ï¼Œä¸å»é‡ï¼‰
                    const stageData = [];
                    chapterPlanData.forEach(item => {
                        const stageSeq = Number(item.stageSeq);
                        if (!isNaN(stageSeq)) {
                            stageData.push({
                                id: stageSeq,
                                chapterId: chapterId,
                                stage: stageSeq,
                                stageType: item.stageType,
                                bossAnim: item.bossAnim || ''
                            });
                        }
                    });
                    stageData.sort((a, b) => a.id - b.id);
                    
                    // æ„å»ºstageEvent_idæ•°æ®ï¼ˆåªå¤„ç†å…³å¡ç±»å‹ä¸º4çš„è¡Œï¼‰
                    const eventData = [];
                    chapterPlanData.forEach(item => {
                        const stageType = Number(item.stageType);
                        if (stageType === 4) {
                            const stageSeq = Number(item.stageSeq);
                            if (!isNaN(stageSeq)) {
                                let eventId = '';
                                let eventFirst = '';
                                
                                // å¦‚æœ"éšæœºäº‹ä»¶(è§„åˆ’)"åˆ—æœ‰å€¼ï¼ˆå­—ç¬¦ä¸²ç±»å‹ï¼‰ï¼Œä½¿ç”¨è¯¥å€¼å¡«å…¥"äº‹ä»¶éšæœº"åˆ—
                                const randomEventValue = item.randomEvent;
                                
                                // è°ƒè¯•æ—¥å¿—ï¼šå½“å°å…³åºå·ä¸º3æ—¶è¾“å‡ºè¯¦ç»†ä¿¡æ¯
                                if (stageSeq === 3) {
                                    console.log('å°å…³åºå·ä¸º3çš„éšæœºäº‹ä»¶æŸ¥æ‰¾:', {
                                        ç« èŠ‚ID: chapterId,
                                        å°å…³åºå·: stageSeq,
                                        å…³å¡ç±»å‹: stageType,
                                        randomEventValueåŸå§‹å€¼: randomEventValue,
                                        randomEventValueç±»å‹: typeof randomEventValue,
                                        randomEventValueæ˜¯å¦ä¸ºç©º: randomEventValue === '' || randomEventValue === null || randomEventValue === undefined,
                                        randomEventColIndex: randomEventColIndex,
                                        _debugRandomEventRaw: item._debugRandomEventRaw,
                                        itemå®Œæ•´æ•°æ®: item
                                    });
                                }
                                
                                // æ›´ä¸¥æ ¼çš„åˆ¤æ–­ï¼šç¡®ä¿å€¼ä¸ä¸ºç©ºä¸”ä¸æ˜¯ç©ºå­—ç¬¦ä¸²
                                const hasRandomEventValue = randomEventValue !== '' && 
                                                           randomEventValue !== null && 
                                                           randomEventValue !== undefined &&
                                                           String(randomEventValue).trim() !== '';
                                
                                if (hasRandomEventValue) {
                                    // ç¡®ä¿æ˜¯å­—ç¬¦ä¸²ç±»å‹
                                    eventId = String(randomEventValue).trim();
                                    // å¦‚æœ"é¦–æ¬¡éšæœºäº‹ä»¶"åˆ—æœ‰å€¼ï¼Œä½¿ç”¨è¯¥å€¼å¡«å…¥"é¦–æ¬¡äº‹ä»¶"åˆ—
                                    const firstRandomEventValue = item.firstRandomEvent;
                                    if (firstRandomEventValue && firstRandomEventValue !== '' && firstRandomEventValue !== null && firstRandomEventValue !== undefined) {
                                        eventFirst = String(firstRandomEventValue).trim();
                                    }
                                    
                                    // è°ƒè¯•æ—¥å¿—
                                    if (stageSeq === 3) {
                                        console.log('ä½¿ç”¨éšæœºäº‹ä»¶(è§„åˆ’)åˆ—çš„å€¼:', {
                                            eventId: eventId,
                                            firstRandomEventValue: firstRandomEventValue,
                                            eventFirst: eventFirst
                                        });
                                    }
                                } else {
                                    // å¦‚æœ"éšæœºäº‹ä»¶(è§„åˆ’)"åˆ—æ²¡æœ‰å€¼ï¼Œä»"éšæœºäº‹ä»¶"sheeté¡µä¸­"äº‹ä»¶åˆ†å¸ƒ"åˆ—æ‰€æœ‰æ•°æ®ä¸­éšæœºä¸€ä¸ªå€¼
                                    if (randomEventList.length > 0) {
                                        const randomIndex = Math.floor(Math.random() * randomEventList.length);
                                        const selectedEvent = randomEventList[randomIndex];
                                        eventId = String(selectedEvent.eventDistribution).trim();
                                        // åŒæ—¶å°†è¯¥å€¼å¯¹åº”çš„"é¦–æ¬¡äº‹ä»¶"åˆ—çš„å€¼å¡«å…¥"é¦–æ¬¡äº‹ä»¶"åˆ—
                                        eventFirst = String(selectedEvent.firstEvent || '').trim();
                                        
                                        // è°ƒè¯•æ—¥å¿—
                                        if (stageSeq === 3) {
                                            console.log('ä»éšæœºäº‹ä»¶sheeté¡µéšæœºé€‰æ‹©:', {
                                                éšæœºé€‰æ‹©çš„å€¼: eventId,
                                                é¦–æ¬¡äº‹ä»¶: eventFirst
                                            });
                                        }
                                    }
                                }
                                
                                eventData.push({
                                    id: stageSeq,
                                    eventId: eventId,
                                    eventFirst: eventFirst
                                });
                            }
                        }
                    });
                    eventData.sort((a, b) => a.id - b.id);
                    
                    // æ„å»ºstageBattle_idæ•°æ®ï¼ˆé€è¡Œéå†ï¼‰
                    const battleData = [];
                    chapterPlanData.forEach(item => {
                        const stageSeq = Number(item.stageSeq);
                        if (!isNaN(stageSeq)) {
                            const group = stageSeq * 100 + 1;
                            battleData.push({
                                id: stageSeq,
                                hp: item.standardHp || '',
                                atk: item.standardAtk || '',
                                firstHp: '',
                                firstAtk: '',
                                group: group,
                                rogue: '',
                                point: '',
                                roll: '',
                                diceHand: item.diceHand || '',
                                prop: item.prop || '',
                                enemyExp: item.enemyExp || '',
                                stageExp: ''
                            });
                        }
                    });
                    battleData.sort((a, b) => a.id - b.id);
                    
                    // æ„å»ºgroup_idæ•°æ®ï¼ˆä»chapterGroupDataï¼‰
                    const groupData = chapterGroupData.map(item => ({
                        uniqueId: item.uniqueId,
                        enemyGroupId: item.enemyGroupId,
                        enemyId: item.enemyId,
                        position: item.position,
                        start: '',
                        passiveSkill: '',
                        hpTimes: item.hpTimes,
                        atkTimes: item.atkTimes,
                        skillOrder: ''
                    })).sort((a, b) => {
                        // å…ˆæŒ‰enemyGroupIdæ’åºï¼Œå†æŒ‰uniqueIdæ’åº
                        if (a.enemyGroupId !== b.enemyGroupId) {
                            return a.enemyGroupId - b.enemyGroupId;
                        }
                        return a.uniqueId - b.uniqueId;
                    });
                    
                    // åˆ›å»º4ä¸ªsheeté¡µ
                    const stageSheet = createStageSheet(chapterId, stageData);
                    const stageEventSheet = createStageEventSheet(chapterId, eventData);
                    const stageBattleSheet = createStageBattleSheet(chapterId, battleData);
                    const groupSheet = createGroupSheet(chapterId, groupData);
                    
                    // åˆ›å»ºæ–°çš„å·¥ä½œç°¿
                    const newWorkbook = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(newWorkbook, stageSheet, `stage_${chapterId}`);
                    XLSX.utils.book_append_sheet(newWorkbook, stageEventSheet, `stageEvent_${chapterId}`);
                    XLSX.utils.book_append_sheet(newWorkbook, stageBattleSheet, `stageBattle_${chapterId}`);
                    XLSX.utils.book_append_sheet(newWorkbook, groupSheet, `group_${chapterId}`);

                    const fileName = `ç¬¬${chapterId}ç« .xlsx`;
                    XLSX.writeFile(newWorkbook, fileName, { bookType: 'xlsx' });
                }, index * 300);
            });

            const resultDiv = document.getElementById('exportResult');
            resultDiv.innerHTML = `<strong>å¯¼å‡ºå®Œæˆï¼</strong><br>å·²å¯¼å‡º ${sortedChapterIds.length} ä¸ªæ–‡ä»¶`;
            resultDiv.style.display = 'block';
        }

        // å¯¼å‡ºæ€ªç‰©ç»„ï¼ˆå¸¦ç‰ˆæœ¬å·ï¼‰
        function exportMonsterGroup() {
            if (!processedWorkbook) {
                alert('è¯·å…ˆå¤„ç†æ•°æ®ï¼ˆæ­¥éª¤2ï¼‰');
                return;
            }
            
            // æ‰¾åˆ°"æ€ªç‰©ç»„"sheeté¡µ
            let monsterGroupSheet = null;
            let monsterGroupSheetName = null;
            for (let sheetName of processedWorkbook.SheetNames) {
                if (sheetName.includes('æ€ªç‰©ç»„')) {
                    monsterGroupSheet = processedWorkbook.Sheets[sheetName];
                    monsterGroupSheetName = sheetName;
                    break;
                }
            }
            
            if (!monsterGroupSheet) {
                alert('æœªæ‰¾åˆ°"æ€ªç‰©ç»„"sheeté¡µ');
                return;
            }
            
            // åˆ›å»ºæ–°çš„å·¥ä½œç°¿ï¼ŒåªåŒ…å«"æ€ªç‰©ç»„"sheeté¡µ
            const newWorkbook = XLSX.utils.book_new();
            const jsonData = XLSX.utils.sheet_to_json(monsterGroupSheet, { header: 1, defval: '', raw: false });
            const newSheet = XLSX.utils.aoa_to_sheet(jsonData);
            XLSX.utils.book_append_sheet(newWorkbook, newSheet, monsterGroupSheetName);
            
            const fileName = `æ€ªç‰©ç»„_v${VERSION}.xlsx`;
            XLSX.writeFile(newWorkbook, fileName, { bookType: 'xlsx' });
            
            const resultDiv = document.getElementById('exportResult');
            resultDiv.innerHTML = `<strong>å¯¼å‡ºå®Œæˆï¼</strong><br>å·²å¯¼å‡ºæ–‡ä»¶ï¼š${fileName}`;
            resultDiv.style.display = 'block';
        }

        // ç”Ÿæˆç« èŠ‚æ–‡ä»¶ï¼ˆæ—§å‡½æ•°ï¼Œä¿ç•™å¤‡ç”¨ï¼‰
        function generateChapterFiles() {
            if (!workbookData) {
                alert('è¯·å…ˆä¸Šä¼ æ–‡ä»¶');
                return;
            }
            
            const chapterIdCol = document.getElementById('chapterIdCol').value;
            if (!chapterIdCol) {
                alert('è¯·æŒ‡å®šç« èŠ‚IDåˆ—');
                return;
            }
            
            // æ‰¾åˆ°ç« èŠ‚æ€»sheeté¡µ
            let chapterSheet = null;
            for (let sheetName of workbookData.SheetNames) {
                if (sheetName.includes('ç« èŠ‚æ€»') || sheetName.includes('æ€»è¡¨')) {
                    chapterSheet = workbookData.Sheets[sheetName];
                    break;
                }
            }
            
            if (!chapterSheet && workbookData.SheetNames.length > 0) {
                chapterSheet = workbookData.Sheets[workbookData.SheetNames[0]];
            }
            
            if (!chapterSheet) {
                alert('æ‰¾ä¸åˆ°ç« èŠ‚æ€»è¡¨');
                return;
            }
            
            // æå–ç« èŠ‚IDåˆ—è¡¨
            const chapterIds = extractChapterIds(chapterSheet, chapterIdCol);
            
            if (chapterIds.length === 0) {
                alert('æœªæ‰¾åˆ°ç« èŠ‚ID');
                return;
            }
            
            // è·å–å…³å¡è§„åˆ’æ€»sheeté¡µåç§°
            const stagePlanSheetName = document.getElementById('stagePlanSheet').value || 
                (workbookData.SheetNames.find(name => name.includes('å…³å¡è§„åˆ’æ€»') || name.includes('è§„åˆ’æ€»') || name.includes('å…³å¡')) || '');
            
            // ä¸ºæ¯ä¸ªç« èŠ‚IDç”Ÿæˆæ–‡ä»¶
            chapterIds.forEach((chapterId, index) => {
                setTimeout(() => {
                    const newWorkbook = XLSX.utils.book_new();
                    
                    // è·å–stageæ•°æ®
                    const stageData = getStageDataFromPlanSheet(chapterId);
                    
                    // åˆ›å»º4ä¸ªsheeté¡µ
                    const stageSheet = createStageSheet(chapterId, stageData);
                    const stageEventSheet = createStageEventSheet(chapterId);
                    const stageBattleSheet = createStageBattleSheet(chapterId);
                    const groupSheet = createGroupSheet(chapterId);
                    
                    // æ·»åŠ sheeté¡µåˆ°å·¥ä½œç°¿
                    XLSX.utils.book_append_sheet(newWorkbook, stageSheet, `stage_${chapterId}`);
                    XLSX.utils.book_append_sheet(newWorkbook, stageEventSheet, `stageEvent_${chapterId}`);
                    XLSX.utils.book_append_sheet(newWorkbook, stageBattleSheet, `stageBattle_${chapterId}`);
                    XLSX.utils.book_append_sheet(newWorkbook, groupSheet, `group_${chapterId}`);
                    
                    // ç”Ÿæˆæ–‡ä»¶å
                    const fileName = `ç¬¬${chapterId}ç« .xlsm`;
                    
                    // ä¸‹è½½æ–‡ä»¶
                    XLSX.writeFile(newWorkbook, fileName, { bookType: 'xlsm' });
                    
                    // åœ¨æ–°çª—å£ä¸­æ˜¾ç¤ºæ–‡ä»¶å†…å®¹
                    displayGeneratedFile(newWorkbook, fileName, chapterId);
                    
                }, index * 500); // å»¶è¿Ÿç”Ÿæˆï¼Œé¿å…æµè§ˆå™¨é˜»æ­¢å¤šä¸ªä¸‹è½½
            });
            
            alert(`æ­£åœ¨ç”Ÿæˆ ${chapterIds.length} ä¸ªç« èŠ‚æ–‡ä»¶...\næ–‡ä»¶å°†åœ¨æ–°çª—å£ä¸­æ˜¾ç¤ºã€‚`);
        }

        // åœ¨æ–°çª—å£ä¸­æ˜¾ç¤ºç”Ÿæˆçš„æ–‡ä»¶
        function displayGeneratedFile(workbook, fileName, chapterId) {
            const newWindow = window.open('', `ç¬¬${chapterId}ç« `, 'width=1400,height=800,scrollbars=yes');
            
            if (!newWindow) {
                alert('æ— æ³•æ‰“å¼€æ–°çª—å£ï¼Œè¯·å…è®¸å¼¹å‡ºçª—å£');
                return;
            }
            
            // å‡†å¤‡æ‰€æœ‰sheetçš„æ•°æ®
            const allSheetsData = {};
            workbook.SheetNames.forEach(sheetName => {
                allSheetsData[sheetName] = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1, defval: '' });
            });
            
            // ä½¿ç”¨Blobå’ŒURL.createObjectURLåˆ›å»ºHTMLæ–‡ä»¶
            const htmlParts = [];
            htmlParts.push('<!DOCTYPE html>');
            htmlParts.push('<html lang="zh-CN">');
            htmlParts.push('<head>');
            htmlParts.push('<meta charset="UTF-8">');
            htmlParts.push('<title>' + fileName.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</title>');
            htmlParts.push('<style>');
            htmlParts.push('* { margin: 0; padding: 0; box-sizing: border-box; }');
            htmlParts.push('body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }');
            htmlParts.push('.container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 15px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); }');
            htmlParts.push('h1 { color: #667eea; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e9ecef; }');
            htmlParts.push('.sheet-tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }');
            htmlParts.push('.sheet-tab { padding: 10px 20px; background: #f0f0f0; border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: all 0.3s; font-weight: 500; }');
            htmlParts.push('.sheet-tab:hover { background: #e0e0e0; }');
            htmlParts.push('.sheet-tab.active { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }');
            htmlParts.push('.table-wrapper { overflow: auto; max-height: 600px; border: 2px solid #ddd; border-radius: 8px; }');
            htmlParts.push('table { border-collapse: collapse; width: 100%; font-size: 0.9em; min-width: 100%; }');
            htmlParts.push('th, td { border: 1px solid #dee2e6; padding: 8px; text-align: left; white-space: nowrap; }');
            htmlParts.push('th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; position: sticky; top: 0; z-index: 10; font-weight: 600; }');
            htmlParts.push('th:first-child { position: sticky; left: 0; z-index: 11; background: linear-gradient(135deg, #5568d3 0%, #653a92 100%); }');
            htmlParts.push('td:first-child { position: sticky; left: 0; background: #f8f9fa; font-weight: 600; z-index: 9; text-align: center; }');
            htmlParts.push('tr:nth-child(even) { background: #f8f9fa; }');
            htmlParts.push('tr:hover { background: #e7f3ff; }');
            htmlParts.push('.row-header { background: #6c757d !important; color: white !important; min-width: 50px; text-align: center !important; }');
            htmlParts.push('</style>');
            htmlParts.push('</head>');
            htmlParts.push('<body>');
            htmlParts.push('<div class="container">');
            htmlParts.push('<h1>ğŸ“„ ' + fileName.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</h1>');
            htmlParts.push('<div class="sheet-tabs" id="sheetTabs"></div>');
            htmlParts.push('<div id="tableContainer"></div>');
            htmlParts.push('</div>');
            htmlParts.push('<script>');
            htmlParts.push('var allSheetsData = ' + JSON.stringify(allSheetsData).replace(/</g, '\\u003c').replace(/>/g, '\\u003e') + ';');
            htmlParts.push('var sheetNames = ' + JSON.stringify(workbook.SheetNames).replace(/</g, '\\u003c').replace(/>/g, '\\u003e') + ';');
            htmlParts.push('function escapeHtml(text) {');
            htmlParts.push('    var div = document.createElement("div");');
            htmlParts.push('    div.textContent = text;');
            htmlParts.push('    return div.innerHTML;');
            htmlParts.push('}');
            htmlParts.push('function getExcelColumnName(colIndex) {');
            htmlParts.push('    var result = "";');
            htmlParts.push('    while (colIndex >= 0) {');
            htmlParts.push('        result = String.fromCharCode(65 + (colIndex % 26)) + result;');
            htmlParts.push('        colIndex = Math.floor(colIndex / 26) - 1;');
            htmlParts.push('    }');
            htmlParts.push('    return result;');
            htmlParts.push('}');
            htmlParts.push('function renderSheet(sheetName) {');
            htmlParts.push('    var data = allSheetsData[sheetName] || [];');
            htmlParts.push('    if (data.length === 0) {');
            htmlParts.push('        document.getElementById("tableContainer").innerHTML = "<p>æ­¤sheeté¡µæ— æ•°æ®</p>";');
            htmlParts.push('        return;');
            htmlParts.push('    }');
            htmlParts.push('    var html = "<div class=\'table-wrapper\'><table><thead><tr>";');
            htmlParts.push('    html += "<th class=\'row-header\'>è¡Œ/åˆ—</th>";');
            htmlParts.push('    var maxCols = 0;');
            htmlParts.push('    for (var i = 0; i < data.length; i++) {');
            htmlParts.push('        if (data[i].length > maxCols) maxCols = data[i].length;');
            htmlParts.push('    }');
            htmlParts.push('    for (var col = 0; col < maxCols; col++) {');
            htmlParts.push('        var colName = getExcelColumnName(col);');
            htmlParts.push('        html += "<th>" + escapeHtml(colName) + "</th>";');
            htmlParts.push('    }');
            htmlParts.push('    html += "</tr></thead><tbody>";');
            htmlParts.push('    for (var row = 0; row < data.length; row++) {');
            htmlParts.push('        html += "<tr>";');
            htmlParts.push('        html += "<td class=\'row-header\'>" + (row + 1) + "</td>";');
            htmlParts.push('        for (var col = 0; col < maxCols; col++) {');
            htmlParts.push('            var cellValue = data[row][col] !== undefined ? data[row][col] : "";');
            htmlParts.push('            var displayValue = cellValue === "" ? "&nbsp;" : escapeHtml(String(cellValue));');
            htmlParts.push('            html += "<td>" + displayValue + "</td>";');
            htmlParts.push('        }');
            htmlParts.push('        html += "</tr>";');
            htmlParts.push('    }');
            htmlParts.push('    html += "</tbody></table></div>";');
            htmlParts.push('    document.getElementById("tableContainer").innerHTML = html;');
            htmlParts.push('}');
            htmlParts.push('sheetNames.forEach(function(name, index) {');
            htmlParts.push('    var tab = document.createElement("div");');
            htmlParts.push('    tab.className = "sheet-tab" + (index === 0 ? " active" : "");');
            htmlParts.push('    tab.textContent = name;');
            htmlParts.push('    tab.onclick = function() {');
            htmlParts.push('        var tabs = document.querySelectorAll(".sheet-tab");');
            htmlParts.push('        for (var i = 0; i < tabs.length; i++) {');
            htmlParts.push('            tabs[i].classList.remove("active");');
            htmlParts.push('        }');
            htmlParts.push('        tab.classList.add("active");');
            htmlParts.push('        renderSheet(name);');
            htmlParts.push('    };');
            htmlParts.push('    document.getElementById("sheetTabs").appendChild(tab);');
            htmlParts.push('});');
            htmlParts.push('if (sheetNames.length > 0) {');
            htmlParts.push('    renderSheet(sheetNames[0]);');
            htmlParts.push('}');
            htmlParts.push('</' + 'script>');
            htmlParts.push('</body>');
            htmlParts.push('</html>');
            
            const htmlContent = htmlParts.join('\n');
            newWindow.document.write(htmlContent);
            newWindow.document.close();
        }

        // æ¸…é™¤æ–‡ä»¶
        function clearFile() {
            if (confirm('ç¡®å®šè¦æ¸…é™¤å½“å‰æ–‡ä»¶å—ï¼Ÿ')) {
                workbook = null;
                workbookData = null;
                currentSheetName = null;
                fileInput.value = '';
                fileInfo.classList.remove('show');
                controls.classList.remove('show');
                if (stepControls) {
                    stepControls.classList.remove('show');
                }
                displaySection.classList.remove('show');
                uploadArea.classList.remove('dragover');
            }
        }
    </script>
</body>
</html>

